---
title: 비관계형 데이터 및 NoSQL
description: ''
author: zoinerTejada
ms:date: 02/12/2018
ms.openlocfilehash: 2c284099bd7e8bbb85f1252a24d699d9fca09eae
ms.sourcegitcommit: 51f49026ec46af0860de55f6c082490e46792794
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/03/2018
---
# <a name="non-relational-data-and-nosql"></a><span data-ttu-id="bc50d-102">비관계형 데이터 및 NoSQL</span><span class="sxs-lookup"><span data-stu-id="bc50d-102">Non-relational data and NoSQL</span></span>

<span data-ttu-id="bc50d-103">*비관계형 데이터베이스*는 대부분의 전형적인 데이터베이스 시스템에서 찾을 수 있는 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-103">A *non-relational database* is a database that does not use the tabular schema of rows and columns found in most traditional database systems.</span></span> <span data-ttu-id="bc50d-104">대신 비관계형 데이터베이스는 저장되는 데이터 형식의 특정 요구 사항에 맞게 최적화된 저장소 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-104">Instead, non-relational databases use a storage model that is optimized for the specific requirements of the type of data being stored.</span></span> <span data-ttu-id="bc50d-105">예를 들어, 데이터는 단순 키/값 쌍, JSON 문서 또는 모서리와 꼭짓점으로 이루어진 그래프로 저장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-105">For example, data may be stored as simple key/value pairs, as JSON documents, or as a graph consisting of edges and vertices.</span></span> 

<span data-ttu-id="bc50d-106">이러한 모든 데이터 저장소가 갖는 공통점은 [관계형 모델](../relational-data/index.md)을 사용하지 않는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-106">What all of these data stores have in common is that they don't use a [relational model](../relational-data/index.md).</span></span> <span data-ttu-id="bc50d-107">또한 지원하는 데이터 형식과 데이터를 쿼리할 수 있는 방법도 좀 더 구체적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-107">Also, they tend to be more specific in the type of data they support and how data can be queried.</span></span> <span data-ttu-id="bc50d-108">예를 들어, 시계열 데이터 저장소는 시간 기준 데이터 시퀀스에 대한 쿼리에 맞게 최적화되어 있지만, 그래프 데이터 저장소는 엔터티 간에 가중치가 적용된 관계를 탐색하는 데 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-108">For example, time series data stores are optimized for queries over time-based sequences of data, while graph data stores are optimized for exploring weighted relationships between entities.</span></span> <span data-ttu-id="bc50d-109">두 형식 모두 트랜잭션 데이터의 관리 태스크로는 잘 일반화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-109">Neither format would generalize well to the task of managing transactional data.</span></span> 

<span data-ttu-id="bc50d-110">용어 *NoSQL*은 쿼리에 SQL을 사용하지 않고, 대신 다른 프로그래밍 언어 및 구문을 사용하여 데이터를 쿼리하는 데이터 저장소를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-110">The term *NoSQL* refers to data stores that do not use SQL for queries, and instead use other programming languages and constructs to query the data.</span></span> <span data-ttu-id="bc50d-111">실제로, 이러한 많은 데이터베이스가 SQL 호환 쿼리를 지원하더라도, "NoSQL"은 "비관계형 데이터베이스"를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-111">In practice, "NoSQL" means "non-relational database," even though many of these databases do support SQL-compatible queries.</span></span> <span data-ttu-id="bc50d-112">그러나 기본 쿼리 실행 전략은 일반적으로 전형적인 RDBMS가 동일한 SQL 쿼리를 실행하는 방식과 매우 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-112">However, the underlying query execution strategy is usually very different from the way a traditional RDBMS would execute the same SQL query.</span></span>

<span data-ttu-id="bc50d-113">다음 섹션에서는 비관계형 또는 NoSQL 데이터베이스의 주요 범주를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-113">The following sections describe the major categories of non-relational or NoSQL database.</span></span>

## <a name="document-data-stores"></a><span data-ttu-id="bc50d-114">문서 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-114">Document data stores</span></span>
<span data-ttu-id="bc50d-115">문서 데이터 저장소는 *문서*라고 하는 엔터티에서 명명된 문자열 필드 및 개체 데이터 값의 집합을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-115">A document data store manages a set of named string fields and object data values in an entity referred to as a *document*.</span></span> <span data-ttu-id="bc50d-116">일반적으로 이러한 데이터 저장소는 JSON 문서 형식으로 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-116">These data stores typically store data in the form of JSON documents.</span></span> <span data-ttu-id="bc50d-117">각 필드 값은 숫자와 같은 스칼라 항목이거나 목록 또는 부모-자식 컬렉션과 같은 복합 요소일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-117">Each field value could be a scalar item, such as a number, or a compound element, such as a list or a parent-child collection.</span></span> <span data-ttu-id="bc50d-118">문서 필드의 데이터는 XML, YAML, JSON, BSON을 비롯한 다양한 방법으로 인코딩되거나 일반 텍스트로 저장될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-118">The data in the fields of a document can be encoded in a variety of ways, including XML, YAML, JSON, BSON, or even stored as plain text.</span></span> <span data-ttu-id="bc50d-119">문서 내의 필드는 저장소 관리 시스템에 표시되므로 응용 프로그램에서 이러한 필드의 값을 사용하여 데이터를 쿼리하고 필터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-119">The fields within documents are exposed to the storage management system, enabling an application to query and filter data by using the values in these fields.</span></span>  

<span data-ttu-id="bc50d-120">일반적으로 문서에는 엔터티의 전체 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-120">Typically, a document contains the entire data for an entity.</span></span> <span data-ttu-id="bc50d-121">엔터티를 구성하는 항목은 응용 프로그램에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-121">What items constitute an entity are application specific.</span></span> <span data-ttu-id="bc50d-122">예를 들어, 엔터티에는 고객의 세부 정보, 주문 또는 이 두 정보의 조합을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-122">For example, an entity could contain the details of a customer, an order, or a combination of both.</span></span> <span data-ttu-id="bc50d-123">RDBMS(관계형 데이터베이스 관리 시스템)의 여러 관계형 테이블에 분산된 정보가 단일 문서에 포함될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-123">A single document might contain information that would be spread across several relational tables in a relational database management system (RDBMS).</span></span> <span data-ttu-id="bc50d-124">문서 저장소의 모든 문서가 동일한 구조를 가질 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-124">A document store does not require that all documents have the same structure.</span></span> <span data-ttu-id="bc50d-125">이 자유 형식 접근 방식은 많은 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-125">This free-form approach provides a great deal of flexibility.</span></span> <span data-ttu-id="bc50d-126">예를 들어, 비즈니스 요구 사항의 변경에 대한 응답으로, 응용 프로그램은 문서에 다른 데이터를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-126">For example, applications can store different data in documents in response to a change in business requirements.</span></span>  

![예제 문서 데이터 저장소](./images/document.png)  

<span data-ttu-id="bc50d-128">응용 프로그램은 문서 키를 사용하여 문서를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-128">The application can retrieve documents by using the document key.</span></span> <span data-ttu-id="bc50d-129">문서 키란 데이터를 균등하게 분산하는 데 사용되는 문서의 고유 식별자로서 종종 해시됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-129">This is a unique identifier for the document, which is often hashed, to help distribute data evenly.</span></span> <span data-ttu-id="bc50d-130">일부 문서 데이터베이스는 자동으로 문서 키를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-130">Some document databases create the document key automatically.</span></span> <span data-ttu-id="bc50d-131">다른 문서 데이터베이스에서는 키로 사용할 문서의 특성을 사용자가 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-131">Others enable you to specify an attribute of the document to use as the key.</span></span> <span data-ttu-id="bc50d-132">응용 프로그램은 하나 이상의 필드 값을 기반으로 문서를 쿼리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-132">The application can also query documents based on the value of one or more fields.</span></span> <span data-ttu-id="bc50d-133">일부 문서 데이터베이스는 하나 이상의 인덱싱된 필드를 기반으로 문서를 빠르게 조회할 수 있도록 인덱싱을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-133">Some document databases support indexing to facilitate fast lookup of documents based on one or more indexed fields.</span></span>  

<span data-ttu-id="bc50d-134">많은 문서 데이터베이스에서는 응용 프로그램에서 전체 문서를 다시 작성하지 않고도 문서의 특정 필드 값을 수정할 수 있는 내부 업데이트를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-134">Many document databases support in-place updates, enabling an application to modify the values of specific fields in a document without rewriting the entire document.</span></span> <span data-ttu-id="bc50d-135">단일 문서의 여러 필드에 대한 읽기 및 쓰기 작업은 일반적으로 원자성입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-135">Read and write operations over multiple fields in a single document are usually atomic.</span></span>

<span data-ttu-id="bc50d-136">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-136">Relevant Azure service:</span></span>  

- [<span data-ttu-id="bc50d-137">Azure Cosmos DB</span><span class="sxs-lookup"><span data-stu-id="bc50d-137">Azure Cosmos DB</span></span>](https://azure.microsoft.com/services/cosmos-db/)

## <a name="columnar-data-stores"></a><span data-ttu-id="bc50d-138">칼럼 형식 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-138">Columnar data stores</span></span>
<span data-ttu-id="bc50d-139">칼럼 형식 또는 열 패밀리 데이터 저장소는 데이터를 열과 행으로 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-139">A columnar or column-family data store organizes data into columns and rows.</span></span> <span data-ttu-id="bc50d-140">가장 간단한 형태인 열 패밀리 데이터 저장소는 적어도 개념적으로 관계형 데이터베이스와 매우 유사하게 보일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-140">In its simplest form, a column-family data store can appear very similar to a relational database, at least conceptually.</span></span> <span data-ttu-id="bc50d-141">열 패밀리 데이터베이스의 이점은 데이터를 저장하는 열 기반 접근법에서 파생된 스파스 데이터를 구조화하기 위한 비정규화된 접근법에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-141">The real power of a column-family database lies in its denormalized approach to structuring sparse data, which stems from the column-oriented approach to storing data.</span></span>  

<span data-ttu-id="bc50d-142">열 패밀리 데이터 저장소는 행과 열이 있는 표 형식 데이터로 생각할 수 있지만 열은 열 패밀리라는 그룹으로 나뉩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-142">You can think of a column-family data store as holding tabular data with rows and columns, but the columns are divided into groups known as column families.</span></span> <span data-ttu-id="bc50d-143">각 열 패밀리는 논리적으로 관련되어 있고 일반적으로 하나의 단위로 검색되거나 조작되는 열 집합을 보유합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-143">Each column family holds a set of columns that are logically related and are typically retrieved or manipulated as a unit.</span></span> <span data-ttu-id="bc50d-144">개별적으로 액세스되는 다른 데이터는 별도의 열 패밀리에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-144">Other data that is accessed separately can be stored in separate column families.</span></span> <span data-ttu-id="bc50d-145">열 패밀리 내에서 새 열을 동적으로 추가할 수 있고 행은 스파스될 수 있습니다. 즉, 행은 모든 열에 대해 값을 가질 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-145">Within a column family, new columns can be added dynamically, and rows can be sparse (that is, a row doesn't need to have a value for every column).</span></span> 

<span data-ttu-id="bc50d-146">다음 다이어그램은 `Identity` 및 `Contact Info`의 두 열 패밀리가 있는 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-146">The following diagram shows an example with two column families, `Identity` and `Contact Info`.</span></span> <span data-ttu-id="bc50d-147">단일 엔터티의 데이터에는 각 열 패밀리에서 동일한 행 키가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-147">The data for a single entity has the same row key in each column family.</span></span> <span data-ttu-id="bc50d-148">열 패밀리의 특정 개체에 대한 행이 동적으로 달라질 수 있는 이 구조는 열 패밀리 접근 방식의 중요한 이점이므로 이 데이터 저장소 형식은 다양한 스키마와 함께 데이터를 저장하는 데 매우 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-148">This structure, where the rows for any given object in a column family can vary dynamically, is an important benefit of the column-family approach, making this form of data store highly suited for storing data with varying schemas.</span></span>

![열 패밀리 데이터의 예](../../guide/technology-choices/images/column-family.png)

<span data-ttu-id="bc50d-150">키/값 저장소 또는 문서 데이터베이스와 달리 대부분의 열 패밀리 데이터베이스는 해시를 계산하지 않고 키 순서로 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-150">Unlike a key/value store or a document database, most column-family databases physically store data in key order, rather than by computing a hash.</span></span> <span data-ttu-id="bc50d-151">행 키는 기본 인덱스로 간주되며, 특정 키 또는 키 범위를 통한 키 기반 액세스를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-151">The row key is considered the primary index and enables key-based access via a specific key or a range of keys.</span></span> <span data-ttu-id="bc50d-152">일부 구현을 통해 열 패밀리의 특정 열에 대한 보조 인덱스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-152">Some implementations allow you to create secondary indexes over specific columns in a column family.</span></span> <span data-ttu-id="bc50d-153">보조 인덱스를 사용하면 행 키가 아닌 열 값으로 데이터를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-153">Secondary indexes let you retrieve data by columns value, rather than row key.</span></span>

<span data-ttu-id="bc50d-154">디스크에서 열 패밀리 내의 모든 열은 동일한 파일에 함께 저장되며, 각 파일에는 특정 수의 행이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-154">On disk, all of the columns within a column family are stored together in the same file, with a certain number of rows in each file.</span></span> <span data-ttu-id="bc50d-155">큰 데이터 집합을 사용할 경우 이 접근법은 한 번에 몇 개의 열만 쿼리될 때 디스크에서 읽어야 하는 데이터 양을 줄임으로써 성능을 높여줍니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-155">With large data sets, this approach creates a performance benefit by reducing the amount of data that needs to be read from disk when only a few columns are queried together at a time.</span></span> 

<span data-ttu-id="bc50d-156">행에 대한 읽기 및 쓰기 작업은 일반적으로 단일 열 패밀리에 대해 원자성이지만 일부 구현은 여러 열 패밀리에 걸쳐 전체 행에 원자성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-156">Read and write operations for a row are usually atomic within a single column family, although some implementations provide atomicity across the entire row, spanning multiple column families.</span></span>

<span data-ttu-id="bc50d-157">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-157">Relevant Azure service:</span></span>  

- [<span data-ttu-id="bc50d-158">HDInsight의 HBase</span><span class="sxs-lookup"><span data-stu-id="bc50d-158">HBase in HDInsight</span></span>](/azure/hdinsight/hdinsight-hbase-overview)

## <a name="keyvalue-data-stores"></a><span data-ttu-id="bc50d-159">키/값 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-159">Key/value data stores</span></span>
<span data-ttu-id="bc50d-160">키/값 저장소는 기본적으로 큰 해시 테이블입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-160">A key/value store is essentially a large hash table.</span></span> <span data-ttu-id="bc50d-161">각 데이터 값을 고유한 키와 연결하고 키/값 저장소는 이 키를 사용하여 적절한 해시 알고리즘을 통해 데이터를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-161">You associate each data value with a unique key, and the key/value store uses this key to store the data by using an appropriate hashing function.</span></span> <span data-ttu-id="bc50d-162">해시 알고리즘은 데이터 저장소 전반에 해시 키가 균등하게 분산되도록 하기 위해 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-162">The hashing function is selected to provide an even distribution of hashed keys across the data storage.</span></span>

<span data-ttu-id="bc50d-163">대부분의 키/값 저장소는 간단한 쿼리, 삽입 및 삭제 작업만 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-163">Most key/value stores only support simple query, insert, and delete operations.</span></span> <span data-ttu-id="bc50d-164">값을 수정(부분적으로 또는 완전히)하려면 응용 프로그램이 전체 값에 대해 기존 데이터를 덮어써야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-164">To modify a value (either partially or completely), an application must overwrite the existing data for the entire value.</span></span> <span data-ttu-id="bc50d-165">대부분의 구현에서 단일 값 읽기 또는 쓰기는 원자성 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-165">In most implementations, reading or writing a single value is an atomic operation.</span></span> <span data-ttu-id="bc50d-166">값이 클 경우 쓸 때 약간의 시간이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-166">If the value is large, writing may take some time.</span></span>

<span data-ttu-id="bc50d-167">응용 프로그램은 임의의 데이터를 값 집합으로 저장할 수 있지만 일부 키/값 저장소는 값의 최대 크기를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-167">An application can store arbitrary data as a set of values, although some key/value stores impose limits on the maximum size of values.</span></span> <span data-ttu-id="bc50d-168">저장된 값은 저장소 시스템 소프트웨어에 불투명합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-168">The stored values are opaque to the storage system software.</span></span> <span data-ttu-id="bc50d-169">모든 스키마 정보는 응용 프로그램에서 제공하고 해석해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-169">Any schema information must be provided and interpreted by the application.</span></span> <span data-ttu-id="bc50d-170">본질적으로 값은 BLOB이며 키/값 저장소는 키로 값을 검색하거나 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-170">Essentially, values are blobs and the key/value store simply retrieves or stores the value by key.</span></span>

![키/값 저장소의 데이터 예](../../guide/technology-choices/images/key-value.png)

<span data-ttu-id="bc50d-172">키/값 저장소는 키의 값을 사용하거나 키 범위별로 간단한 조회를 수행하는 응용 프로그램에 대해 최적화되어 있지만, 여러 테이블 간에 데이터를 조인하는 경우처럼 다른 키/값 테이블 사이에서 데이터를 쿼리해야 하는 시스템에는 덜 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-172">Key/value stores are highly optimized for applications performing simple lookups using the value of the key, or by a range of keys, but are less suitable for systems that need to query data across different tables of keys/values, such as joining data across multiple tables.</span></span> 

<span data-ttu-id="bc50d-173">키/값 저장소는 키에 따라서만 조회를 수행하는 것이 아니라 키 이외의 값별 조회나 필터링이 중요한 시나리오에 대해서도 최적화되어 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-173">Key/value stores are also not optimized for scenarios where querying or filtering by non-key values is important, rather than performing lookups based only on keys.</span></span> <span data-ttu-id="bc50d-174">예를 들어, 관계형 데이터베이스의 경우 WHERE 절을 사용하여 키가 아닌 열을 필터링함으로써 레코드를 찾을 수 있지만, 키/값 저장소는 일반적으로 값에 대해 이러한 유형의 조회 기능을 제공하지 않으며, 제공한다고 해도 모든 값을 느리게 검색할 수밖에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-174">For example, with a relational database, you can find a record by using a WHERE clause to filter the non-key columns, but key/values stores usually do not have this type of lookup capability for values, or if they do it requires a slow scan of all values.</span></span>

<span data-ttu-id="bc50d-175">단일 키/값 저장소는 별도의 컴퓨터에 있는 여러 노드에 데이터를 쉽게 배포할 수 있으므로 확장성이 매우 뛰어납니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-175">A single key/value store can be extremely scalable, as the data store can easily distribute data across multiple nodes on separate machines.</span></span>

<span data-ttu-id="bc50d-176">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-176">Relevant Azure services:</span></span>  
- [<span data-ttu-id="bc50d-177">Azure Cosmos DB 테이블 API</span><span class="sxs-lookup"><span data-stu-id="bc50d-177">Azure Cosmos DB Table API</span></span>](/azure/cosmos-db/table-introduction)  
- [<span data-ttu-id="bc50d-178">Azure Redis 캐시(영문)</span><span class="sxs-lookup"><span data-stu-id="bc50d-178">Azure Redis Cache</span></span>](https://azure.microsoft.com/services/cache/)  
- [<span data-ttu-id="bc50d-179">Azure Table Storage</span><span class="sxs-lookup"><span data-stu-id="bc50d-179">Azure Table Storage</span></span>](https://azure.microsoft.com/services/storage/tables/)

## <a name="graph-data-stores"></a><span data-ttu-id="bc50d-180">그래프 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-180">Graph data stores</span></span>
<span data-ttu-id="bc50d-181">그래프 데이터 저장소는 노드와 에지, 두 가지 유형의 정보를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-181">A graph data store manages two types of information, nodes and edges.</span></span> <span data-ttu-id="bc50d-182">노드는 엔터티를 나타내고, 에지는 이러한 엔터티 간의 관계를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-182">Nodes represent entities, and edges specify the relationships between these entities.</span></span> <span data-ttu-id="bc50d-183">노드와 에지 모두 테이블의 열과 마찬가지로 해당 노드 또는 에지에 대한 정보를 제공하는 속성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-183">Both nodes and edges can have properties that provide information about that node or edge, similar to columns in a table.</span></span> <span data-ttu-id="bc50d-184">에지는 또한 관계의 특성을 나타내는 방향을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-184">Edges can also have a direction indicating the nature of the relationship.</span></span>  

<span data-ttu-id="bc50d-185">그래프 데이터 저장소의 목적은 응용 프로그램이 노드와 에지의 네트워크를 트래버스하는 쿼리를 효율적으로 수행하고 엔터티 간의 관계를 분석할 수 있게 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-185">The purpose of a graph data store is to allow an application to efficiently perform queries that traverse the network of nodes and edges, and to analyze the relationships between entities.</span></span> <span data-ttu-id="bc50d-186">다음 다이어그램은 그래프로 구성된 조직의 인사 데이터를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-186">The following diagram shows an organization's personnel data structured as a graph.</span></span> <span data-ttu-id="bc50d-187">엔터티는 직원 및 부서이며, 에지는 보고 관계 및 직원이 근무하는 부서를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-187">The entities are employees and departments, and the edges indicate reporting relationships and the department in which employees work.</span></span> <span data-ttu-id="bc50d-188">이 그래프에서 에지의 화살표는 관계 방향을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-188">In this graph, the arrows on the edges show the direction of the relationships.</span></span>

![그래프 데이터 저장소의 데이터 예](../../guide/technology-choices/images/graph.png)

<span data-ttu-id="bc50d-190">이 구조를 통해 "Sarah에게 직접 또는 간접적으로 보고하는 모든 직원 찾기" 또는 "John과 같은 부서에서 근무하는 직원"과 같은 쿼리를 간단하게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-190">This structure makes it straightforward to perform queries such as "Find all employees who report directly or indirectly to Sarah" or "Who works in the same department as John?"</span></span> <span data-ttu-id="bc50d-191">엔터티와 관계가 많은 대형 그래프의 경우 매우 복잡한 분석을 매우 신속하게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-191">For large graphs with lots of entities and relationships, you can perform very complex analyses very quickly.</span></span> <span data-ttu-id="bc50d-192">많은 그래프 데이터베이스는 관계 네트워크를 효율적으로 트래버스하는 데 사용할 수 있는 쿼리 언어를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-192">Many graph databases provide a query language that you can use to traverse a network of relationships efficiently.</span></span>  

<span data-ttu-id="bc50d-193">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-193">Relevant Azure service:</span></span>  
- [<span data-ttu-id="bc50d-194">Azure Cosmos DB Graph API</span><span class="sxs-lookup"><span data-stu-id="bc50d-194">Azure Cosmos DB Graph API</span></span>](/azure/cosmos-db/graph-introduction)  

## <a name="time-series-data-stores"></a><span data-ttu-id="bc50d-195">시계열 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-195">Time series data stores</span></span>
<span data-ttu-id="bc50d-196">시계열 데이터는 시간별로 구성된 값 집합이며 시계열 데이터 저장소는 이러한 유형의 데이터에 대해 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-196">Time series data is a set of values organized by time, and a time series data store is optimized for this type of data.</span></span> <span data-ttu-id="bc50d-197">시계열 데이터 저장소는 대개 여러 소스에서 대량의 데이터를 실시간으로 수집하기 때문에 매우 많은 쓰기를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-197">Time series data stores must support a very high number of writes, as they typically collect large amounts of data in real time from a large number of sources.</span></span> <span data-ttu-id="bc50d-198">시계열 데이터 저장소는 원격 분석 데이터를 저장하도록 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-198">Time series data stores are optimized for storing telemetry data.</span></span> <span data-ttu-id="bc50d-199">시나리오에는 IoT 센서 또는 응용 프로그램/시스템 카운터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-199">Scenarios include IoT sensors or application/system counters.</span></span> <span data-ttu-id="bc50d-200">업데이트는 거의 발생하지 않으며 삭제는 종종 대량 작업으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-200">Updates are rare, and deletes are often done as bulk operations.</span></span>

![시계열 데이터의 예](./images/time-series.png)

<span data-ttu-id="bc50d-202">시계열 데이터베이스에 기록된 레코드는 일반적으로 작지만 레코드 수가 많아 전체 데이터 크기가 빠르게 커지는 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-202">Although the records written to a time series database are generally small, there are often a large number of records, and total data size can grow rapidly.</span></span> <span data-ttu-id="bc50d-203">시계열 데이터 저장소는 순서가 맞지 않고 늦게 도착하는 데이터, 데이터 요소의 자동 인덱싱, 시간 측면에서 기술된 쿼리의 최적화도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-203">Time series data stores also handle out-of-order and late-arriving data, automatic indexing of data points, and optimizations for queries described in terms of windows of time.</span></span> <span data-ttu-id="bc50d-204">이 마지막 기능을 사용하면 시계열 데이터가 사용되는 일반적인 방식에 해당하는 시계열 시각화를 지원하기 위해, 수백만 개의 데이터 요소 및 여러 데이터 스트림 간에 빠르게 쿼리를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-204">This last feature enables queries to run across millions of data points and multiple data streams quickly, in order to support time series visualizations, which is a common way that time series data is consumed.</span></span> 

<span data-ttu-id="bc50d-205">자세한 내용은 [시계열 솔루션](../scenarios/time-series.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bc50d-205">For more information, see [Time series solutions](../scenarios/time-series.md)</span></span>

<span data-ttu-id="bc50d-206">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-206">Relevant Azure service:</span></span>  
- [<span data-ttu-id="bc50d-207">Azure Time Series Insights</span><span class="sxs-lookup"><span data-stu-id="bc50d-207">Azure Time Series Insights</span></span>](https://azure.microsoft.com/services/time-series-insights/)  
- [<span data-ttu-id="bc50d-208">HDInsight의 OpenTSDB(HBase 포함)</span><span class="sxs-lookup"><span data-stu-id="bc50d-208">OpenTSDB with HBase on HDInsight</span></span>](/azure/hdinsight/hdinsight-hbase-overview)

## <a name="object-data-stores"></a><span data-ttu-id="bc50d-209">개체 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-209">Object data stores</span></span>
<span data-ttu-id="bc50d-210">개체 데이터 저장소는 대형 이진 개체 또는 Blob(예: 이미지, 텍스트 파일, 비디오 및 오디오 스트림, 대형 응용 프로그램 데이터 개체 및 문서, 가상 머신 디스크 이미지)를 저장하고 검색하는 데 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-210">Object data stores are optimized for storing and retrieving large binary objects or blobs such as images, text files, video and audio streams, large application data objects and documents, and virtual machine disk images.</span></span> <span data-ttu-id="bc50d-211">개체는 저장된 데이터, 일부 메타데이터 및 개체에 액세스하기 위한 고유한 ID로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-211">An object consists of the stored data, some metadata, and a unique ID for accessing the object.</span></span> <span data-ttu-id="bc50d-212">개체 저장소는 개별적으로 매우 큰 파일을 지원할 뿐만 아니라 모든 파일을 관리하기 위해 용량이 큰 저장소를 제공하도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-212">Object stores are designed to support files that are individually very large, as well provide large amounts of total storage to manage all files.</span></span>  

![개체 데이터의 예](./images/object.png)

<span data-ttu-id="bc50d-214">일부 개체 데이터 저장소는 여러 서버 노드에서 지정된 Blob을 복제하여 빠른 병렬 읽기를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-214">Some object data stores replicate a given blob across multiple server nodes, which enables fast parallel reads.</span></span> <span data-ttu-id="bc50d-215">일반적으로 여러 다른 서버에서 실행되는 여러 프로세스가 큰 데이터 파일을 동시에 쿼리할 수 있으므로 이를 통해 큰 파일에 포함된 데이터에 대한 스케일 아웃 쿼리가 가능해집니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-215">This in turn enables the scale-out querying of data contained in large files, because multiple processes, typically running on different servers, can each query the large data file simultaneously.</span></span>

<span data-ttu-id="bc50d-216">개체 데이터 저장소의 특수 경우는 네트워크 파일 공유입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-216">One special case of object data stores is the network file share.</span></span> <span data-ttu-id="bc50d-217">파일 공유를 사용하면 SMB(서버 메시지 블록)와 같은 표준 네트워킹 프로토콜을 사용하여 네트워크를 통해 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-217">Using file shares enables files to be accessed across a network using standard networking protocols like server message block (SMB).</span></span> <span data-ttu-id="bc50d-218">적절한 보안 및 동시 액세스 제어 메커니즘이 제공되면 이러한 방식으로 데이터를 공유하여, 분산 서비스를 통해 단순 읽기 및 쓰기 요청과 같은 기본, 저수준 작업을 위한 확장성이 뛰어난 데이터 액세스를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-218">Given appropriate security and concurrent access control mechanisms, sharing data in this way can enable distributed services to provide highly scalable data access for basic, low level operations such as simple read and write requests.</span></span>

<span data-ttu-id="bc50d-219">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-219">Relevant Azure service:</span></span>   

- [<span data-ttu-id="bc50d-220">Azure Blob Storage</span><span class="sxs-lookup"><span data-stu-id="bc50d-220">Azure Blob Storage</span></span>](https://azure.microsoft.com/services/storage/blobs/)  
- [<span data-ttu-id="bc50d-221">Azure Data Lake Storage</span><span class="sxs-lookup"><span data-stu-id="bc50d-221">Azure Data Lake Store</span></span>](https://azure.microsoft.com/services/data-lake-store/)  
- [<span data-ttu-id="bc50d-222">Azure File Storage</span><span class="sxs-lookup"><span data-stu-id="bc50d-222">Azure File Storage</span></span>](https://azure.microsoft.com/services/storage/files/)  


## <a name="external-index-data-stores"></a><span data-ttu-id="bc50d-223">외부 인덱스 데이터 저장소</span><span class="sxs-lookup"><span data-stu-id="bc50d-223">External index data stores</span></span>

<span data-ttu-id="bc50d-224">외부 인덱스 데이터 저장소는 다른 데이터 저장소 및 서비스에 보관된 정보를 검색하는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-224">External index data stores provide the ability to search for information held in other data stores and services.</span></span> <span data-ttu-id="bc50d-225">외부 인덱스는 모든 데이터 저장소에 대한 보조 인덱스 역할을 하며, 대량의 데이터를 인덱싱하고 이러한 인덱스에 대해 거의 실시간 액세스를 제공하는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-225">An external index acts as a secondary index for any data store, and can be used to index massive volumes of data and provide near real-time access to these indexes.</span></span> 

<span data-ttu-id="bc50d-226">예를 들어, 파일 시스템에 저장된 텍스트 파일이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-226">For example, you might have text files stored in a file system.</span></span> <span data-ttu-id="bc50d-227">파일 경로로 파일을 빠르게 찾을 수 있지만, 파일 내용을 기준으로 검색하려면 모든 파일을 검색해야 하므로 느립니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-227">Finding a file by its file path is quick, but searching based on the contents of the file would require a scan of all of the files, which is slow.</span></span> <span data-ttu-id="bc50d-228">외부 인덱스를 사용하면 보조 검색 인덱스를 만들고, 조건에 일치하는 파일의 경로를 빠르게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-228">An external index lets you create secondary search indexes and then quickly find the path to the files that match your criteria.</span></span> <span data-ttu-id="bc50d-229">외부 인덱스를 적용한 또 다른 예는 키로만 인덱싱하는 키/값 저장소를 사용하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-229">Another example application of an external index is with key/value stores that only index by the key.</span></span> <span data-ttu-id="bc50d-230">데이터의 값에 따라 보조 인덱스를 작성할 수 있으며, 일치하는 각 항목을 고유하게 식별하는 키를 신속하게 조회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-230">You can build a secondary index based on the values in the data, and quickly look up the key that uniquely identifies each matched item.</span></span> 

![검색 데이터의 예](./images/search.png)

<span data-ttu-id="bc50d-232">인덱스는 인덱싱 프로세스를 실행하여 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-232">The indexes are created by running an indexing process.</span></span> <span data-ttu-id="bc50d-233">이 작업은 데이터 저장소에 의해 트리거되는 끌어오기 모델을 사용하거나 응용 프로그램 코드에 의해 시작되는 밀어넣기 모델을 사용하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-233">This can be performed using a pull model, triggered by the data store, or using a push model, initiated by application code.</span></span> <span data-ttu-id="bc50d-234">인덱스는 다차원적일 수 있으며 많은 양의 텍스트 데이터에서 자유 텍스트 검색을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-234">Indexes can be multidimensional and may support free-text searches across large volumes of text data.</span></span> 

<span data-ttu-id="bc50d-235">외부 인덱스 데이터 저장소는 전체 텍스트 및 웹 기반 검색을 지원하는 데 종종 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-235">External index data stores are often used to support full text and web based search.</span></span> <span data-ttu-id="bc50d-236">이러한 경우 검색은 정확한 항목 또는 유사 항목을 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-236">In these cases, searching can be exact or fuzzy.</span></span> <span data-ttu-id="bc50d-237">유사 항목 검색은 용어 집합과 일치하는 문서를 찾고 일치하는 정도를 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-237">A fuzzy search finds documents that match a set of terms and calculates how closely they match.</span></span> <span data-ttu-id="bc50d-238">또한 일부 외부 인덱스는 동의어, 장르 확장(예를 들어, "dogs"를 검색하면 "pets"가 검색됨), 형태소 분석(예를 들어: "run"을 검색하면 “ran” 및 “running”도 검색됨)에 따라 일치 항목을 반환할 수 있는 언어 분석도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-238">Some external indexes also support linguistic analysis that can return matches based on synonyms, genre expansions (for example, matching "dogs" to "pets"), and stemming (for example, searching for "run" also matches "ran" and "running").</span></span> 

<span data-ttu-id="bc50d-239">관련 Azure 서비스:</span><span class="sxs-lookup"><span data-stu-id="bc50d-239">Relevant Azure service:</span></span>  

- [<span data-ttu-id="bc50d-240">Azure Search</span><span class="sxs-lookup"><span data-stu-id="bc50d-240">Azure Search</span></span>](https://azure.microsoft.com/services/search/)


## <a name="typical-requirements"></a><span data-ttu-id="bc50d-241">일반적인 요구 사항</span><span class="sxs-lookup"><span data-stu-id="bc50d-241">Typical requirements</span></span>
<span data-ttu-id="bc50d-242">비관계형 데이터 저장소는 종종 관계형 데이터베이스에서 사용되는 다른 저장소 아키텍처를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-242">Non-relational data stores often use a different storage architecture from that used by relational databases.</span></span> <span data-ttu-id="bc50d-243">특히, 고정된 스키마가 없는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-243">Specifically, they tend towards having no fixed schema.</span></span> <span data-ttu-id="bc50d-244">또한 트랜잭션을 지원하지 않거나 트랜잭션 범위를 제한하는 경향이 있으며, 일반적으로 확장성 때문에 보조 인덱스를 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-244">Also, they tend not to support transactions, or else restrict the scope of transactions, and they generally don't include secondary indexes for scalability reasons.</span></span>

<span data-ttu-id="bc50d-245">다음은 각 비관계형 데이터 저장소의 요구 사항을 비교해서 설명한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="bc50d-245">The following compares the requirements for each of the non-relational data stores:</span></span>

| <span data-ttu-id="bc50d-246">요구 사항</span><span class="sxs-lookup"><span data-stu-id="bc50d-246">Requirement</span></span> | <span data-ttu-id="bc50d-247">문서 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-247">Document data</span></span> | <span data-ttu-id="bc50d-248">열 패밀리 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-248">Column-family data</span></span> | <span data-ttu-id="bc50d-249">키/값 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-249">Key/value data</span></span> | <span data-ttu-id="bc50d-250">그래프 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-250">Graph data</span></span> | 
| --- | --- | --- | --- | --- | 
| <span data-ttu-id="bc50d-251">정규화</span><span class="sxs-lookup"><span data-stu-id="bc50d-251">Normalization</span></span> | <span data-ttu-id="bc50d-252">비정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-252">Denormalized</span></span> | <span data-ttu-id="bc50d-253">비정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-253">Denormalized</span></span> | <span data-ttu-id="bc50d-254">비정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-254">Denormalized</span></span> | <span data-ttu-id="bc50d-255">정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-255">Normalized</span></span> | 
| <span data-ttu-id="bc50d-256">스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-256">Schema</span></span> | <span data-ttu-id="bc50d-257">읽기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-257">Schema on read</span></span> | <span data-ttu-id="bc50d-258">쓰기 시 열 패밀리 정의, 읽기 시 열 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-258">Column families defined on write, column schema on read</span></span> | <span data-ttu-id="bc50d-259">읽기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-259">Schema on read</span></span> | <span data-ttu-id="bc50d-260">읽기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-260">Schema on read</span></span> | 
| <span data-ttu-id="bc50d-261">일관성(동시 트랜잭션 전체)</span><span class="sxs-lookup"><span data-stu-id="bc50d-261">Consistency (across concurrent transactions)</span></span> | <span data-ttu-id="bc50d-262">튜닝 가능한 일관성, 문서 수준 보장</span><span class="sxs-lookup"><span data-stu-id="bc50d-262">Tunable consistency, document-level guarantees</span></span> | <span data-ttu-id="bc50d-263">열 패밀리 수준 보증</span><span class="sxs-lookup"><span data-stu-id="bc50d-263">Column-family&ndash;level guarantees</span></span> | <span data-ttu-id="bc50d-264">키 수준 보장</span><span class="sxs-lookup"><span data-stu-id="bc50d-264">Key-level guarantees</span></span> | <span data-ttu-id="bc50d-265">그래프 수준 보장</span><span class="sxs-lookup"><span data-stu-id="bc50d-265">Graph-level guarantees</span></span> 
| <span data-ttu-id="bc50d-266">원자성(트랜잭션 범위)</span><span class="sxs-lookup"><span data-stu-id="bc50d-266">Atomicity (transaction scope)</span></span> | <span data-ttu-id="bc50d-267">컬렉션</span><span class="sxs-lookup"><span data-stu-id="bc50d-267">Collection</span></span> | <span data-ttu-id="bc50d-268">테이블</span><span class="sxs-lookup"><span data-stu-id="bc50d-268">Table</span></span> | <span data-ttu-id="bc50d-269">테이블</span><span class="sxs-lookup"><span data-stu-id="bc50d-269">Table</span></span> | <span data-ttu-id="bc50d-270">그래프</span><span class="sxs-lookup"><span data-stu-id="bc50d-270">Graph</span></span> | 
| <span data-ttu-id="bc50d-271">잠금 전략</span><span class="sxs-lookup"><span data-stu-id="bc50d-271">Locking Strategy</span></span> | <span data-ttu-id="bc50d-272">낙관적(잠금 없음)</span><span class="sxs-lookup"><span data-stu-id="bc50d-272">Optimistic (lock free)</span></span> | <span data-ttu-id="bc50d-273">비관적(행 잠금)</span><span class="sxs-lookup"><span data-stu-id="bc50d-273">Pessimistic (row locks)</span></span> | <span data-ttu-id="bc50d-274">낙관적(ETag)</span><span class="sxs-lookup"><span data-stu-id="bc50d-274">Optimistic (ETag)</span></span> | 
| <span data-ttu-id="bc50d-275">액세스 패턴</span><span class="sxs-lookup"><span data-stu-id="bc50d-275">Access pattern</span></span> | <span data-ttu-id="bc50d-276">임의 액세스</span><span class="sxs-lookup"><span data-stu-id="bc50d-276">Random access</span></span> | <span data-ttu-id="bc50d-277">tall/wide 데이터 집계</span><span class="sxs-lookup"><span data-stu-id="bc50d-277">Aggregates on tall/wide data</span></span> | <span data-ttu-id="bc50d-278">임의 액세스</span><span class="sxs-lookup"><span data-stu-id="bc50d-278">Random access</span></span> | <span data-ttu-id="bc50d-279">임의 액세스</span><span class="sxs-lookup"><span data-stu-id="bc50d-279">Random access</span></span> |
| <span data-ttu-id="bc50d-280">인덱싱</span><span class="sxs-lookup"><span data-stu-id="bc50d-280">Indexing</span></span> | <span data-ttu-id="bc50d-281">기본 및 보조 인덱스</span><span class="sxs-lookup"><span data-stu-id="bc50d-281">Primary and secondary indexes</span></span> | <span data-ttu-id="bc50d-282">기본 및 보조 인덱스</span><span class="sxs-lookup"><span data-stu-id="bc50d-282">Primary and secondary indexes</span></span> | <span data-ttu-id="bc50d-283">기본 인덱스만</span><span class="sxs-lookup"><span data-stu-id="bc50d-283">Primary index only</span></span> | <span data-ttu-id="bc50d-284">기본 및 보조 인덱스</span><span class="sxs-lookup"><span data-stu-id="bc50d-284">Primary and secondary indexes</span></span> | 
| <span data-ttu-id="bc50d-285">데이터 모양</span><span class="sxs-lookup"><span data-stu-id="bc50d-285">Data shape</span></span> | <span data-ttu-id="bc50d-286">문서</span><span class="sxs-lookup"><span data-stu-id="bc50d-286">Document</span></span> | <span data-ttu-id="bc50d-287">열이 포함된 열 패밀리가 있는 테이블 형식</span><span class="sxs-lookup"><span data-stu-id="bc50d-287">Tabular with column families containing columns</span></span> | <span data-ttu-id="bc50d-288">키 및 값</span><span class="sxs-lookup"><span data-stu-id="bc50d-288">Key and value</span></span> | <span data-ttu-id="bc50d-289">모서리와 꼭짓점을 포함하는 그래프</span><span class="sxs-lookup"><span data-stu-id="bc50d-289">Graph containing edges and vertices</span></span> | 
| <span data-ttu-id="bc50d-290">스파스</span><span class="sxs-lookup"><span data-stu-id="bc50d-290">Sparse</span></span> | <span data-ttu-id="bc50d-291">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-291">Yes</span></span> | <span data-ttu-id="bc50d-292">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-292">Yes</span></span> | <span data-ttu-id="bc50d-293">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-293">Yes</span></span> | <span data-ttu-id="bc50d-294">아니오</span><span class="sxs-lookup"><span data-stu-id="bc50d-294">No</span></span> | 
| <span data-ttu-id="bc50d-295">넓게(많은 열/특성)</span><span class="sxs-lookup"><span data-stu-id="bc50d-295">Wide (lots of columns/attributes)</span></span> | <span data-ttu-id="bc50d-296">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-296">Yes</span></span> | <span data-ttu-id="bc50d-297">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-297">Yes</span></span> | <span data-ttu-id="bc50d-298">아니요</span><span class="sxs-lookup"><span data-stu-id="bc50d-298">No</span></span> | <span data-ttu-id="bc50d-299">아니오</span><span class="sxs-lookup"><span data-stu-id="bc50d-299">No</span></span> |  
| <span data-ttu-id="bc50d-300">데이터 크기</span><span class="sxs-lookup"><span data-stu-id="bc50d-300">Datum size</span></span> | <span data-ttu-id="bc50d-301">작음(KB) ~ 중간(낮은 MB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-301">Small (KBs) to medium (low MBs)</span></span> | <span data-ttu-id="bc50d-302">중간(MB) ~ 큰(낮은 GB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-302">Medium (MBs) to Large (low GBs)</span></span> | <span data-ttu-id="bc50d-303">작음(KB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-303">Small (KBs)</span></span> | <span data-ttu-id="bc50d-304">작음(KB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-304">Small (KBs)</span></span> | 
| <span data-ttu-id="bc50d-305">전체 최대 크기</span><span class="sxs-lookup"><span data-stu-id="bc50d-305">Overall Maximum Scale</span></span> | <span data-ttu-id="bc50d-306">매우 큼(PB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-306">Very Large (PBs)</span></span> | <span data-ttu-id="bc50d-307">매우 큼(PB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-307">Very Large (PBs)</span></span> | <span data-ttu-id="bc50d-308">매우 큼(PB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-308">Very Large (PBs)</span></span> | <span data-ttu-id="bc50d-309">큼(TB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-309">Large (TBs)</span></span> | 

| <span data-ttu-id="bc50d-310">요구 사항</span><span class="sxs-lookup"><span data-stu-id="bc50d-310">Requirement</span></span> | <span data-ttu-id="bc50d-311">시계열 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-311">Time series data</span></span> | <span data-ttu-id="bc50d-312">개체 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-312">Object data</span></span> | <span data-ttu-id="bc50d-313">외부 인덱스 데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-313">External index data</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="bc50d-314">정규화</span><span class="sxs-lookup"><span data-stu-id="bc50d-314">Normalization</span></span> | <span data-ttu-id="bc50d-315">정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-315">Normalized</span></span> | <span data-ttu-id="bc50d-316">비정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-316">Denormalized</span></span> | <span data-ttu-id="bc50d-317">비정규화됨</span><span class="sxs-lookup"><span data-stu-id="bc50d-317">Denormalized</span></span> |
| <span data-ttu-id="bc50d-318">스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-318">Schema</span></span> | <span data-ttu-id="bc50d-319">읽기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-319">Schema on read</span></span> | <span data-ttu-id="bc50d-320">읽기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-320">Schema on read</span></span> | <span data-ttu-id="bc50d-321">쓰기 시 스키마</span><span class="sxs-lookup"><span data-stu-id="bc50d-321">Schema on write</span></span> | 
| <span data-ttu-id="bc50d-322">일관성(동시 트랜잭션 전체)</span><span class="sxs-lookup"><span data-stu-id="bc50d-322">Consistency (across concurrent transactions)</span></span> | <span data-ttu-id="bc50d-323">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-323">N/A</span></span> | <span data-ttu-id="bc50d-324">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-324">N/A</span></span> | <span data-ttu-id="bc50d-325">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-325">N/A</span></span> | 
| <span data-ttu-id="bc50d-326">원자성(트랜잭션 범위)</span><span class="sxs-lookup"><span data-stu-id="bc50d-326">Atomicity (transaction scope)</span></span> | <span data-ttu-id="bc50d-327">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-327">N/A</span></span> | <span data-ttu-id="bc50d-328">Object</span><span class="sxs-lookup"><span data-stu-id="bc50d-328">Object</span></span> | <span data-ttu-id="bc50d-329">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-329">N/A</span></span> |
| <span data-ttu-id="bc50d-330">잠금 전략</span><span class="sxs-lookup"><span data-stu-id="bc50d-330">Locking Strategy</span></span> | <span data-ttu-id="bc50d-331">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-331">N/A</span></span> | <span data-ttu-id="bc50d-332">비관적(Blob 잠금)</span><span class="sxs-lookup"><span data-stu-id="bc50d-332">Pessimistic (blob locks)</span></span> | <span data-ttu-id="bc50d-333">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-333">N/A</span></span> |
| <span data-ttu-id="bc50d-334">액세스 패턴</span><span class="sxs-lookup"><span data-stu-id="bc50d-334">Access pattern</span></span> | <span data-ttu-id="bc50d-335">임의 액세스 및 집계</span><span class="sxs-lookup"><span data-stu-id="bc50d-335">Random access and aggregation</span></span> | <span data-ttu-id="bc50d-336">순차적 액세스</span><span class="sxs-lookup"><span data-stu-id="bc50d-336">Sequential access</span></span> | <span data-ttu-id="bc50d-337">임의 액세스</span><span class="sxs-lookup"><span data-stu-id="bc50d-337">Random access</span></span> | 
| <span data-ttu-id="bc50d-338">인덱싱</span><span class="sxs-lookup"><span data-stu-id="bc50d-338">Indexing</span></span> | <span data-ttu-id="bc50d-339">기본 및 보조 인덱스</span><span class="sxs-lookup"><span data-stu-id="bc50d-339">Primary and secondary indexes</span></span> | <span data-ttu-id="bc50d-340">기본 인덱스만</span><span class="sxs-lookup"><span data-stu-id="bc50d-340">Primary index only</span></span> | <span data-ttu-id="bc50d-341">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-341">N/A</span></span> |
| <span data-ttu-id="bc50d-342">데이터 모양</span><span class="sxs-lookup"><span data-stu-id="bc50d-342">Data shape</span></span> | <span data-ttu-id="bc50d-343">테이블 형식</span><span class="sxs-lookup"><span data-stu-id="bc50d-343">Tabular</span></span> | <span data-ttu-id="bc50d-344">Blob 및 메타데이터</span><span class="sxs-lookup"><span data-stu-id="bc50d-344">Blob and metadata</span></span> | <span data-ttu-id="bc50d-345">문서</span><span class="sxs-lookup"><span data-stu-id="bc50d-345">Document</span></span> |
| <span data-ttu-id="bc50d-346">스파스</span><span class="sxs-lookup"><span data-stu-id="bc50d-346">Sparse</span></span> | <span data-ttu-id="bc50d-347">아니요</span><span class="sxs-lookup"><span data-stu-id="bc50d-347">No</span></span> | <span data-ttu-id="bc50d-348">해당 없음</span><span class="sxs-lookup"><span data-stu-id="bc50d-348">N/A</span></span> | <span data-ttu-id="bc50d-349">아니오</span><span class="sxs-lookup"><span data-stu-id="bc50d-349">No</span></span> | 
| <span data-ttu-id="bc50d-350">넓게(많은 열/특성)</span><span class="sxs-lookup"><span data-stu-id="bc50d-350">Wide (lots of columns/attributes)</span></span> |  <span data-ttu-id="bc50d-351">아니오</span><span class="sxs-lookup"><span data-stu-id="bc50d-351">No</span></span> | <span data-ttu-id="bc50d-352">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-352">Yes</span></span> | <span data-ttu-id="bc50d-353">예</span><span class="sxs-lookup"><span data-stu-id="bc50d-353">Yes</span></span> |  
| <span data-ttu-id="bc50d-354">데이터 크기</span><span class="sxs-lookup"><span data-stu-id="bc50d-354">Datum size</span></span> | <span data-ttu-id="bc50d-355">작음(KB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-355">Small (KBs)</span></span> | <span data-ttu-id="bc50d-356">큼(TB) ~ 매우 큼(TB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-356">Large (GBs) to Very Large (TBs)</span></span> | <span data-ttu-id="bc50d-357">작음(KB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-357">Small (KBs)</span></span> |
| <span data-ttu-id="bc50d-358">전체 최대 크기</span><span class="sxs-lookup"><span data-stu-id="bc50d-358">Overall Maximum Scale</span></span> | <span data-ttu-id="bc50d-359">큼(낮은 TB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-359">Large (low TBs)</span></span>  | <span data-ttu-id="bc50d-360">매우 큼(PB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-360">Very Large (PBs)</span></span> | <span data-ttu-id="bc50d-361">큼(낮은 TB)</span><span class="sxs-lookup"><span data-stu-id="bc50d-361">Large (low TBs)</span></span> | 

