---
title: "Scheduler 에이전트 감독자"
description: "서비스 및 기타 원격 리소스의 분산된 집합에서 일련의 작업을 조정합니다."
keywords: "디자인 패턴"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- messaging
- resiliency
ms.openlocfilehash: 03bfe2fe96b3b81d547cfedb075bcf855846b668
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
---
# <a name="scheduler-agent-supervisor-pattern"></a><span data-ttu-id="03d77-104">Scheduler 에이전트 감독자 패턴</span><span class="sxs-lookup"><span data-stu-id="03d77-104">Scheduler Agent Supervisor pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="03d77-105">분산된 작업 집합을 단일 작업으로 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-105">Coordinate a set of distributed actions as a single operation.</span></span> <span data-ttu-id="03d77-106">작업 중 하나라도 실패하는 경우 실패를 투명하게 처리하거나 수행된 작업을 취소합니다. 그래야 전체 작업이 성공하며 그렇지 않으면 전체가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-106">If any of the actions fail, try to handle the failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a whole.</span></span> <span data-ttu-id="03d77-107">이는 일시적 예외, 오래 지속된 오류 및 프로세스 오류로 인해 실패한 작업을 복구하고 다시 시도하도록 함으로써 분산된 시스템에 복원력을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-107">This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail due to transient exceptions, long-lasting faults, and process failures.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="03d77-108">컨텍스트 및 문제점</span><span class="sxs-lookup"><span data-stu-id="03d77-108">Context and problem</span></span>

<span data-ttu-id="03d77-109">응용 프로그램은 여러 단계를 포함하고 그 중 일부가 원격 서비스를 호출하거나 원격 리소스에 액세스할 수 있는 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-109">An application performs tasks that include a number of steps, some of which might invoke remote services or access remote resources.</span></span> <span data-ttu-id="03d77-110">개별 단계는 서로 독립적일 수 있지만, 작업을 구현하는 응용 프로그램 논리에 의해 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-110">The individual steps might be independent of each other, but they are orchestrated by the application logic that implements the task.</span></span>

<span data-ttu-id="03d77-111">응용 프로그램은 가능하면 작업이 완료되도록 하고 원격 서비스 또는 리소스에 액세스할 때 발생할 수 있는 모든 오류를 해결하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-111">Whenever possible, the application should ensure that the task runs to completion and resolve any failures that might occur when accessing remote services or resources.</span></span> <span data-ttu-id="03d77-112">오류는 여러 가지 이유로 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-112">Failures can occur for many reasons.</span></span> <span data-ttu-id="03d77-113">예를 들어, 네트워크가 정지되거나 통신이 중단되거나 원격 서비스가 응답하지 않거나 불안정한 상태에 있거나 원격 리소스를 리소스 제약 등으로 인해 일시적으로 액세스할 수 없는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-113">For example, the network might be down, communications could be interrupted, a remote service might be unresponsive or in an unstable state, or a remote resource might be temporarily inaccessible, perhaps due to resource constraints.</span></span> <span data-ttu-id="03d77-114">대부분의 경우 오류는 일시적인 것이며 [다시 시도 패턴][retry-pattern]을 사용하여 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-114">In many cases the failures will be transient and can be handled by using the [Retry pattern][retry-pattern].</span></span>

<span data-ttu-id="03d77-115">응용 프로그램이 쉽게 복구할 수 없는 더욱 영구적인 오류를 탐지하는 경우 시스템을 일관된 상태로 복원하여 전체 작업의 무결성을 보장할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-115">If the application detects a more permanent fault it can't easily recover from, it must be able to restore the system to a consistent state and ensure integrity of the entire operation.</span></span>

## <a name="solution"></a><span data-ttu-id="03d77-116">해결 방법</span><span class="sxs-lookup"><span data-stu-id="03d77-116">Solution</span></span>

<span data-ttu-id="03d77-117">Scheduler 에이전트 감독자 패턴은 다음과 같은 행위자를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-117">The Scheduler Agent Supervisor pattern defines the following actors.</span></span> <span data-ttu-id="03d77-118">이러한 행위자는 전체 작업의 일부로 수행하는 단계를 오케스트레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-118">These actors orchestrate the steps to be performed as part of the overall task.</span></span>

- <span data-ttu-id="03d77-119">**Scheduler**는 실행할 작업을 구성하는 단계를 준비하고 작업을 오케스트레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-119">The **Scheduler** arranges for the steps that make up the task to be executed and orchestrates their operation.</span></span> <span data-ttu-id="03d77-120">이들 단계는 파이프라인 또는 워크플로에 결합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-120">These steps can be combined into a pipeline or workflow.</span></span> <span data-ttu-id="03d77-121">Scheduler는 이 워크플로의 단계가 올바른 순서대로 수행되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-121">The Scheduler is responsible for ensuring that the steps in this workflow are performed in the right order.</span></span> <span data-ttu-id="03d77-122">각 단계를 수행할 때, Scheduler는 "단계가 아직 시작되지 않음", "단계 실행 중" 또는 "단계 완료" 등 워크플로의 상태를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-122">As each step is performed, the Scheduler records the state of the workflow, such as "step not yet started," "step running," or "step completed."</span></span> <span data-ttu-id="03d77-123">상태 정보에는 완료 제한 시간이라고 하는 단계를 끝내는 데 허용된 시간의 상한이 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-123">The state information should also include an upper limit of the time allowed for the step to finish, called the complete-by time.</span></span> <span data-ttu-id="03d77-124">원격 서비스 또는 리소스에 대한 액세스가 필요한 단계의 경우 Scheduler는 적절한 에이전트를 호출하여 수행할 작업에 대한 세부 정보를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-124">If a step requires access to a remote service or resource, the Scheduler invokes the appropriate Agent, passing it the details of the work to be performed.</span></span> <span data-ttu-id="03d77-125">Scheduler는 일반적으로 비동기 요청/응답 메시징을 사용하는 에이전트와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-125">The Scheduler typically communicates with an Agent using asynchronous request/response messaging.</span></span> <span data-ttu-id="03d77-126">이는 다른 분산 메시징 기술을 대신 사용할 수 있더라도 큐를 사용하여 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-126">This can be implemented using queues, although other distributed messaging technologies could be used instead.</span></span>

    > <span data-ttu-id="03d77-127">Scheduler는 [프로세스 관리자 패턴](http://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html)의 프로세스 관리자와 비슷한 기능을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-127">The Scheduler performs a similar function to the Process Manager in the [Process Manager pattern](http://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html).</span></span> <span data-ttu-id="03d77-128">실제 워크플로는 일반적으로 Scheduler가 제어하는 워크플로 엔진에 의해 정의되고 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-128">The actual workflow is typically defined and implemented by a workflow engine that's controlled by the Scheduler.</span></span> <span data-ttu-id="03d77-129">이러한 방법은 Scheduler에서 워크플로의 비즈니스 논리를 분리합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-129">This approach decouples the business logic in the workflow from the Scheduler.</span></span>

- <span data-ttu-id="03d77-130">**에이전트**는 원격 서비스에 대한 호출 또는 작업에서 단계별로 참조된 원격 리소스에 대한 액세스를 캡슐화하는 논리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-130">The **Agent** contains logic that encapsulates a call to a remote service, or access to a remote resource referenced by a step in a task.</span></span> <span data-ttu-id="03d77-131">각 에이전트는 일반적으로 단일 서비스 또는 리소스에 대한 호출을 래핑하여 (나중에 설명되는 제한 시간 제약 조건에 따라) 적절한 오류 처리 및 재시도 논리를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-131">Each Agent typically wraps calls to a single service or resource, implementing the appropriate error handling and retry logic (subject to a timeout constraint, described later).</span></span> <span data-ttu-id="03d77-132">Scheduler에 의해 실행되는 워크플로의 단계가 서로 다른 단계의 여러 서비스와 리소스를 사용하는 경우, 각 단계는 다른 에이전트를 참조할 수 있습니다(이는 패턴 구현 세부 정보임).</span><span class="sxs-lookup"><span data-stu-id="03d77-132">If the steps in the workflow being run by the Scheduler use several services and resources across different steps, each step might reference a different Agent (this is an implementation detail of the pattern).</span></span>

- <span data-ttu-id="03d77-133">**감독자**는 Scheduler에서 수행되고 있는 작업 단계의 상태를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-133">The **Supervisor** monitors the status of the steps in the task being performed by the Scheduler.</span></span> <span data-ttu-id="03d77-134">이는 주기적으로 실행되고(빈도는 시스템에 따라 다름), Scheduler에서 유지 관리되는 단계의 상태를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-134">It runs periodically (the frequency will be system specific), and examines the status of steps maintained by the Scheduler.</span></span> <span data-ttu-id="03d77-135">시간을 초과했거나 실패한 것으로 감지되면 적절한 에이전트를 통해 단계를 복구하거나 적절한 수정 작업을 실행합니다(단계 상태 수정 작업을 포함할 수 있음).</span><span class="sxs-lookup"><span data-stu-id="03d77-135">If it detects any that have timed out or failed, it arranges for the appropriate Agent to recover the step or execute the appropriate remedial action (this might involve modifying the status of a step).</span></span> <span data-ttu-id="03d77-136">복구 또는 수정 작업은 Scheduler 및 에이전트에 의해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-136">Note that the recovery or remedial actions are implemented by the Scheduler and Agents.</span></span> <span data-ttu-id="03d77-137">감독자는 이러한 작업이 수행되도록 요청합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-137">The Supervisor should simply request that these actions be performed.</span></span>

<span data-ttu-id="03d77-138">Scheduler, 에이전트 및 감독자는 논리적 구성 요소이며 이들의 물리적 구현은 사용되는 기술에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-138">The Scheduler, Agent, and Supervisor are logical components and their physical implementation depends on the technology being used.</span></span> <span data-ttu-id="03d77-139">예를 들어 여러 논리 에이전트는 단일 웹 서비스의 일부로 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-139">For example, several logical agents might be implemented as part of a single web service.</span></span>

<span data-ttu-id="03d77-140">Scheduler는 작업 진행률과 상태 저장소라고 하는 지속형 데이터 저장소에 있는 각 단계의 상태에 대한 정보를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-140">The Scheduler maintains information about the progress of the task and the state of each step in a durable data store, called the state store.</span></span> <span data-ttu-id="03d77-141">감독자는 단계가 실패했는지 여부를 판단하기 위해 이러한 정보를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-141">The Supervisor can use this information to help determine whether a step has failed.</span></span> <span data-ttu-id="03d77-142">그림은 Scheduler, 에이전트, 감독자 및 상태 저장소 간의 관계를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-142">The figure illustrates the relationship between the Scheduler, the Agents, the Supervisor, and the state store.</span></span>

![그림 1 - Scheduler 에이전트 감독자 패턴의 행위자](./_images/scheduler-agent-supervisor-pattern.png)


> <span data-ttu-id="03d77-144">이 다이어그램에서는 단순화된 패턴 버전을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-144">This diagram shows a simplified version of the pattern.</span></span> <span data-ttu-id="03d77-145">실제 구현에서 각 작업의 하위 집합을 동시에 실행하는 Scheduler의 여러 인스턴스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-145">In a real implementation, there might be many instances of the Scheduler running concurrently, each a subset of tasks.</span></span> <span data-ttu-id="03d77-146">마찬가지로, 시스템은 각 에이전트 또는 여러 감독자의 여러 인스턴스를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-146">Similarly, the system could run multiple instances of each Agent, or even multiple Supervisors.</span></span> <span data-ttu-id="03d77-147">이 경우 감독자는 실패한 같은 단계 및 작업을 복구하기 위해 경쟁하지 않도록 다른 작업과 신중하게 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-147">In this case, Supervisors must coordinate their work with each other carefully to ensure that they don’t compete to recover the same failed steps and tasks.</span></span> <span data-ttu-id="03d77-148">[리더 선택 패턴](leader-election.md)은 이러한 문제에 대해 한 가지 해결책을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-148">The [Leader Election pattern](leader-election.md) provides one possible solution to this problem.</span></span>

<span data-ttu-id="03d77-149">응용 프로그램이 작업을 실행할 준비가 되면 Scheduler에 요청을 제출합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-149">When the application is ready to run a task, it submits a request to the Scheduler.</span></span> <span data-ttu-id="03d77-150">Scheduler는 작업과 해당 단계에 대한 초기 상태 정보(예를 들어, 단계가 아직 시작되지 않음)를 상태 저장소에 기록한 다음 워크플로에 정의된 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-150">The Scheduler records initial state information about the task and its steps (for example, step not yet started) in the state store and then starts performing the operations defined by the workflow.</span></span> <span data-ttu-id="03d77-151">Scheduler가 각 단계를 시작하면 상태 저장소의 해당 단계의 상태 정보(예를 들어, 단계 실행 중)를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-151">As the Scheduler starts each step, it updates the information about the state of that step in the state store (for example, step running).</span></span>

<span data-ttu-id="03d77-152">단계가 원격 서비스 또는 리소스를 참조하는 경우, Scheduler는 적절한 에이전트에 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-152">If a step references a remote service or resource, the Scheduler sends a message to the appropriate Agent.</span></span> <span data-ttu-id="03d77-153">메시지에는 작업에 대한 완료 제한 시간 외에도 에이전트가 서비스에 전달하거나 리소스에 액세스해야 하는 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-153">The message contains the information that the Agent needs to pass to the service or access the resource, in addition to the complete-by time for the operation.</span></span> <span data-ttu-id="03d77-154">에이전트가 작업을 성공적으로 완료하면 Scheduler에 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-154">If the Agent completes its operation successfully, it returns a response to the Scheduler.</span></span> <span data-ttu-id="03d77-155">그런 다음 Scheduler는 상태 저장소의 상태 정보(예를 들어 단계 완료)를 업데이트하고 다음 단계를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-155">The Scheduler can then update the state information in the state store (for example, step completed) and perform the next step.</span></span> <span data-ttu-id="03d77-156">이 프로세스는 전체 작업이 완료될 때까지 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-156">This process continues until the entire task is complete.</span></span>

<span data-ttu-id="03d77-157">에이전트는 작업을 수행하는 데 필요한 모든 재시도 논리를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-157">An Agent can implement any retry logic that's necessary to perform its work.</span></span> <span data-ttu-id="03d77-158">그러나 에이전트가 완료 제한 시간이 만료되기 전에 작업을 완료하지 못하면 Scheduler는 작업이 실패했음으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-158">However, if the Agent doesn't complete its work before the complete-by period expires, the Scheduler will assume that the operation has failed.</span></span> <span data-ttu-id="03d77-159">이 경우 에이전트는 작업을 중단하고 Scheduler에 어떠한 것도 반환하지 않고(오류 메시지도 포함) 어떠한 형태의 복구도 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-159">In this case, the Agent should stop its work and not try to return anything to the Scheduler (not even an error message), or try any form of recovery.</span></span> <span data-ttu-id="03d77-160">이러한 제한을 두는 이유는 단계가 시간을 초과했거나 실패한 후 에이전트의 다른 인스턴스가 실패한 단계를 실행하는 데 예약될 수 있기 때문입니다(이 프로세스는 나중에 설명).</span><span class="sxs-lookup"><span data-stu-id="03d77-160">The reason for this restriction is that, after a step has timed out or failed, another instance of the Agent might be scheduled to run the failing step (this process is described later).</span></span>

<span data-ttu-id="03d77-161">에이전트가 실패하면 Scheduler는 응답을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-161">If the Agent fails, the Scheduler won't receive a response.</span></span> <span data-ttu-id="03d77-162">패턴은 시간을 초과한 단계와 완전히 실패한 단계를 구분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-162">The pattern doesn't make a distinction between a step that has timed out and one that has genuinely failed.</span></span>

<span data-ttu-id="03d77-163">단계가 시간을 초과하거나 실패한 경우 상태 저장소에는 단계가 실행 중이지만 완료 제한 시간을 초과할 것임을 나타내는 레코드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-163">If a step times out or fails, the state store will contain a record that indicates that the step is running, but the complete-by time will have passed.</span></span> <span data-ttu-id="03d77-164">감독자는 이와 같은 단계를 찾아 복구하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-164">The Supervisor looks for steps like this and tries to recover them.</span></span> <span data-ttu-id="03d77-165">한 가지 가능한 전략은 감독자가 완료 제한 값을 업데이트하여 단계를 완료할 시간을 연장한 다음 Scheduler에 메시지를 보내어 단계가 시간을 초과했다는 것을 나타내는 것입니다. 그런 다음 Scheduler는 이 단계를 반복할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-165">One possible strategy is for the Supervisor to update the complete-by value to extend the time available to complete the step, and then send a message to the Scheduler identifying the step that has timed out. The Scheduler can then try to repeat this step.</span></span> <span data-ttu-id="03d77-166">그러나 이러한 디자인의 경우 작업이 idempotent가 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-166">However, this design requires the tasks to be idempotent.</span></span>

<span data-ttu-id="03d77-167">감독자는 단계가 지속적으로 실패하거나 시간을 초과하는 경우 동일한 단계를 다시 시도하는 것을 방지해야 합니다. 이렇게 하면 감독자는 상태 저장소에서 상태 정보와 함께 각 단계에 대한 재시도 횟수를 유지 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-167">The Supervisor might need to prevent the same step from being retried if it continually fails or times out. To do this, the Supervisor could maintain a retry count for each step, along with the state information, in the state store.</span></span> <span data-ttu-id="03d77-168">이 개수가 미리 정의된 임계값을 초과하면 감독자는 이 기간 동안 오류가 해결하기 위해 Scheduler에게 단계를 다시 시도해야 함을 알리기 전에 장시간 동안 기다리는 전략을 채택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-168">If this count exceeds a predefined threshold the Supervisor can adopt a strategy of waiting for an extended period before notifying the Scheduler that it should retry the step, in the expectation that the fault will be resolved during this period.</span></span> <span data-ttu-id="03d77-169">또는 감독자가 Scheduler에 메시지를 보내 [ 트랜잭션 패턴](compensating-transaction.md)을 구현하여 전체 작업의 실행 취소를 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-169">Alternatively, the Supervisor can send a message to the Scheduler to request the entire task be undone by implementing a [Compensating Transaction pattern](compensating-transaction.md).</span></span> <span data-ttu-id="03d77-170">이러한 방법은 성공적으로 완료된 각 단계에 대한 보상 작업을 구현하는 데 필요한 정보를 제공하는 Scheduler와 에이전트에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-170">This approach will depend on the Scheduler and Agents providing the information necessary to implement the compensating operations for each step that completed successfully.</span></span>

> <span data-ttu-id="03d77-171">이는 Scheduler와 에이전트를 모니터링하고 실패한 경우 다시 시작하기 위한 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-171">It isn't the purpose of the Supervisor to monitor the Scheduler and Agents, and restart them if they fail.</span></span> <span data-ttu-id="03d77-172">시스템의 이러한 측면은 이들 구성 요소가 실행되는 인프라에서 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-172">This aspect of the system should be handled by the infrastructure these components are running in.</span></span> <span data-ttu-id="03d77-173">마찬가지로, 감독자는 Scheduler에 의해 수행 중인 작업을 실행하는 실제 비즈니스 업무에 대해 알아서는 안 됩니다(이러한 작업이 실패한 경우 보상 방법 포함).</span><span class="sxs-lookup"><span data-stu-id="03d77-173">Similarly, the Supervisor shouldn't have knowledge of the actual business operations that the tasks being performed by the Scheduler are running (including how to compensate should these tasks fail).</span></span> <span data-ttu-id="03d77-174">이는 Scheduler에 의해 구현되는 워크플로 논리를 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-174">This is the purpose of the workflow logic implemented by the Scheduler.</span></span> <span data-ttu-id="03d77-175">관리자의 유일한 책임은 단계가 실패했는지 여부를 판단하여 이를 반복할지 또는 취소할 실패한 단계를 포함하는 전체 작업을 조정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-175">The sole responsibility of the Supervisor is to determine whether a step has failed and arrange either for it to be repeated or for the entire task containing the failed step to be undone.</span></span>

<span data-ttu-id="03d77-176">실패한 후 Scheduler가 다시 시작되거나 Scheduler에 의해 수행 중인 워크플로가 예기치 않게 종료된 경우, Scheduler는 실패했을 때 처리하고 있던 진행 중인 작업 상태를 판단하고 해당 지점에서 이 작업을 재개할 준비를 할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-176">If the Scheduler is restarted after a failure, or the workflow being performed by the Scheduler terminates unexpectedly, the Scheduler should be able to determine the status of any inflight task that it was handling when it failed, and be prepared to resume this task from that point.</span></span> <span data-ttu-id="03d77-177">이 프로세스의 구현 정보는 시스템에 따라 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-177">The implementation details of this process are likely to be system specific.</span></span> <span data-ttu-id="03d77-178">작업을 복구할 수 없는 경우 이미 수행된 작업을 취소해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-178">If the task can't be recovered, it might be necessary to undo the work already performed by the task.</span></span> <span data-ttu-id="03d77-179">또한 [트랜잭션 보상](compensating-transaction.md)을 구현해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-179">This might also require implementing a [compensating transaction](compensating-transaction.md).</span></span>

<span data-ttu-id="03d77-180">이러한 패턴의 주요 장점은 예기치 않은 일시적 또는 복구할 수 없는 오류 발생 시 시스템이 복원력을 갖는다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-180">The key advantage of this pattern is that the system is resilient in the event of unexpected temporary or unrecoverable failures.</span></span> <span data-ttu-id="03d77-181">시스템은 자체적으로 복구되도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-181">The system can be constructed to be self healing.</span></span> <span data-ttu-id="03d77-182">예를 들어, 에이전트 또는 Scheduler가 실패하는 경우 새로운 에이전트 도는 Scheduler를 시작하고 감독자가 작업을 재개하도록 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-182">For example, if an Agent or the Scheduler fails, a new one can be started and the Supervisor can arrange for a task to be resumed.</span></span> <span data-ttu-id="03d77-183">감독자가 실패하는 경우 다른 인스턴스가 시작되어 오류가 발생한 위치에서부터 재개할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-183">If the Supervisor fails, another instance can be started and can take over from where the failure occurred.</span></span> <span data-ttu-id="03d77-184">감독자를 주기적으로 실행하도록 예약하는 경우 미리 정의된 간격 후 새 인스턴스가 자동으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-184">If the Supervisor is scheduled to run periodically, a new instance can be automatically started after a predefined interval.</span></span> <span data-ttu-id="03d77-185">상태 저장소는 복원력을 더 높이기 위해 복제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-185">The state store can be replicated to reach an even greater degree of resiliency.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="03d77-186">문제 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="03d77-186">Issues and considerations</span></span>

<span data-ttu-id="03d77-187">이 패턴을 구현할 방법을 결정할 때 다음 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-187">You should consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="03d77-188">이 패턴은 구현하기 어려울 수 있으며 시스템의 각 오류 모드의 철저한 테스트가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-188">This pattern can be difficult to implement and requires thorough testing of each possible failure mode of the system.</span></span>

- <span data-ttu-id="03d77-189">Scheduler에 의해 구현되는 복구/재시도 논리는 복잡하며 상태 저장소에 보관된 상태 정보에 좌우됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-189">The recovery/retry logic implemented by the Scheduler is complex and dependent on state information held in the state store.</span></span> <span data-ttu-id="03d77-190">또 지속형 데이터 저장소에 보상 트랜잭션을 구현하는 데 필요한 정보를 기록하는 데 필요할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-190">It might also be necessary to record the information required to implement a compensating transaction in a durable data store.</span></span>

- <span data-ttu-id="03d77-191">감독자 실행 빈도가 중요해집니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-191">How often the Supervisor runs will be important.</span></span> <span data-ttu-id="03d77-192">연장된 기간 동안 실패한 단계가 응용 프로그램을 차단하지 않도록 충분히 자주 실행해야 하지만 과도하게 실행되지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-192">It should run often enough to prevent any failed steps from blocking an application for an extended period, but it shouldn't run so often that it becomes an overhead.</span></span>

- <span data-ttu-id="03d77-193">에이전트에 의해 수행된 단계는 한 번 이상 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-193">The steps performed by an Agent could be run more than once.</span></span> <span data-ttu-id="03d77-194">이들 단계를 구현하는 논리는 idempotent이 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-194">The logic that implements these steps should be idempotent.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="03d77-195">이 패턴을 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="03d77-195">When to use this pattern</span></span>

<span data-ttu-id="03d77-196">클라우드와 같이 분산된 환경에서 실행되는 프로세스가 통신 오류 및/또는 작업 오류에 대해 유연해야 하는 경우 이 패턴을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-196">Use this pattern when a process that runs in a distributed environment, such as the cloud, must be resilient to communications failure and/or operational failure.</span></span>

<span data-ttu-id="03d77-197">이 패턴은 원격 서비스를 호출하지 않거나 원격 리소스에 액세스하지 않는 작업에 적합하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-197">This pattern might not be suitable for tasks that don't invoke remote services or access remote resources.</span></span>

## <a name="example"></a><span data-ttu-id="03d77-198">예</span><span class="sxs-lookup"><span data-stu-id="03d77-198">Example</span></span>

<span data-ttu-id="03d77-199">전자 상거래 시스템을 구현하는 웹 응용 프로그램은 Microsoft Azure에 배포되었습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-199">A web application that implements an ecommerce system has been deployed on Microsoft Azure.</span></span> <span data-ttu-id="03d77-200">사용자는 이 응용 프로그램을 실행하여 제품을 검색하고 주문할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-200">Users can run this application to browse the available products and to place orders.</span></span> <span data-ttu-id="03d77-201">사용자 인터페이스는 웹 역할로 실행되고 응용 프로그램의 주문 처리 요소는 작업자 역할의 집합으로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-201">The user interface runs as a web role, and the order processing elements of the application are implemented as a set of worker roles.</span></span> <span data-ttu-id="03d77-202">주문 처리 논리의 일부분은 원격 서비스 액세스를 포함하고 시스템의 이러한 측면은 일시적이거나 보다 오래 지속되는 오류를 발생시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-202">Part of the order processing logic involves accessing a remote service, and this aspect of the system could be prone to transient or more long-lasting faults.</span></span> <span data-ttu-id="03d77-203">이러한 이유로 설계자는 시스템의 주문 처리 요소를 구현하기 위해 Scheduler 에이전트 감독자 패턴을 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-203">For this reason, the designers used the Scheduler Agent Supervisor pattern to implement the order processing elements of the system.</span></span>

<span data-ttu-id="03d77-204">고객이 주문할 때 응용 프로그램은 주문을 설명하는 메시지를 작성하고 이 메시지를 큐에 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-204">When a customer places an order, the application constructs a message that describes the order and posts this message to a queue.</span></span> <span data-ttu-id="03d77-205">작업자 역할에서 실행되는 별도의 제출 프로세스는 메시지를 검색하고, 주문 세부 정보를 주문 데이터베이스에 삽입하며, 상태 저장소에 주문 프로세스에 대한 레코드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-205">A separate submission process, running in a worker role, retrieves the message, inserts the order details into the orders database, and creates a record for the order process in the state store.</span></span> <span data-ttu-id="03d77-206">주문 데이터베이스와 상태 저장소에 삽입하는 작업은 동일한 작업의 일부로서 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-206">Note that the inserts into the orders database and the state store are performed as part of the same operation.</span></span> <span data-ttu-id="03d77-207">제출 프로세스는 이 두 가지 삽입 작업이 함께 완료되도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-207">The submission process is designed to ensure that both inserts complete together.</span></span>

<span data-ttu-id="03d77-208">주문에 대해 제출 프로세스가 만드는 상태 정보에는 다음이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-208">The state information that the submission process creates for the order includes:</span></span>

- <span data-ttu-id="03d77-209">**OrderID**.</span><span class="sxs-lookup"><span data-stu-id="03d77-209">**OrderID**.</span></span> <span data-ttu-id="03d77-210">주문 데이터베이스의 주문 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-210">The ID of the order in the orders database.</span></span>

- <span data-ttu-id="03d77-211">**LockedBy**.</span><span class="sxs-lookup"><span data-stu-id="03d77-211">**LockedBy**.</span></span> <span data-ttu-id="03d77-212">주문을 처리하는 작업자 역할의 인스턴스 ID입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-212">The instance ID of the worker role handling the order.</span></span> <span data-ttu-id="03d77-213">Scheduler를 실행하는 작업자 역할의 인스턴스가 현재 여러 개 있을 수 있지만 각각의 주문은 단일 인스턴스에 의해서만 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-213">There might be multiple current instances of the worker role running the Scheduler, but each order should only be handled by a single instance.</span></span>

- <span data-ttu-id="03d77-214">**CompleteBy**.</span><span class="sxs-lookup"><span data-stu-id="03d77-214">**CompleteBy**.</span></span> <span data-ttu-id="03d77-215">주문이 처리되어야 하는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-215">The time the order should be processed by.</span></span>

- <span data-ttu-id="03d77-216">**ProcessState**.</span><span class="sxs-lookup"><span data-stu-id="03d77-216">**ProcessState**.</span></span> <span data-ttu-id="03d77-217">주문을 처리하는 작업의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-217">The current state of the task handling the order.</span></span> <span data-ttu-id="03d77-218">가능한 상태는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-218">The possible states are:</span></span>

    - <span data-ttu-id="03d77-219">**보류 중**.</span><span class="sxs-lookup"><span data-stu-id="03d77-219">**Pending**.</span></span> <span data-ttu-id="03d77-220">주문이 생성되었지만 처리가 아직 시작되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-220">The order has been created but processing hasn't yet been started.</span></span>
    - <span data-ttu-id="03d77-221">**처리 중**.</span><span class="sxs-lookup"><span data-stu-id="03d77-221">**Processing**.</span></span> <span data-ttu-id="03d77-222">주문이 현재 처리 중입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-222">The order is currently being processed.</span></span>
    - <span data-ttu-id="03d77-223">**처리됨**.</span><span class="sxs-lookup"><span data-stu-id="03d77-223">**Processed**.</span></span> <span data-ttu-id="03d77-224">주문을 성공적으로 처리했습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-224">The order has been processed successfully.</span></span>
    - <span data-ttu-id="03d77-225">**오류**.</span><span class="sxs-lookup"><span data-stu-id="03d77-225">**Error**.</span></span> <span data-ttu-id="03d77-226">주문 처리가 실패했습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-226">The order processing has failed.</span></span>

- <span data-ttu-id="03d77-227">**FailureCount**.</span><span class="sxs-lookup"><span data-stu-id="03d77-227">**FailureCount**.</span></span> <span data-ttu-id="03d77-228">주문에 대해 시도했던 처리 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-228">The number of times that processing has been tried for the order.</span></span>

<span data-ttu-id="03d77-229">이 상태 정보에서 `OrderID` 필드는 새 주문의 주문 ID에서 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-229">In this state information, the `OrderID` field is copied from the order ID of the new order.</span></span> <span data-ttu-id="03d77-230">`LockedBy` 및 `CompleteBy` 필드는 `null`(으)로 설정되고, `ProcessState` 필드는 `Pending`(으)로 설정되며, `FailureCount` 필드는 0으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-230">The `LockedBy` and `CompleteBy` fields are set to `null`, the `ProcessState` field is set to `Pending`, and the `FailureCount` field is set to 0.</span></span>

> <span data-ttu-id="03d77-231">이 예에서 주문 처리 논리는 비교적 간단하고 원격 서비스를 호출하는 단일 단계만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-231">In this example, the order handling logic is relatively simple and only has a single step that invokes a remote service.</span></span> <span data-ttu-id="03d77-232">좀 더 복잡한 다단계 시나리오에서 제출 프로세스는 다수의 단계를 포함하므로 상태 저장소에 다수의 레코드가 만들어지며, 각 레코드는 개별 단계의 상태를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-232">In a more complex multistep scenario, the submission process would likely involve several steps, and so several records would be created in the state store—each one describing the state of an individual step.</span></span>

<span data-ttu-id="03d77-233">Scheduler는 또한 작업자 역할의 일부로서 실행되고 주문을 처리하는 비즈니스 논리를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-233">The Scheduler also runs as part of a worker role and implements the business logic that handles the order.</span></span> <span data-ttu-id="03d77-234">새 주문에 대해 폴링하는 Scheduler 인스턴스는 `LockedBy` 필드가 null이고 `ProcessState` 필드가 보류 중인 레코드의 상태 저장소를 검사합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-234">An instance of the Scheduler polling for new orders examines the state store for records where the `LockedBy` field is null and the `ProcessState` field is pending.</span></span> <span data-ttu-id="03d77-235">Scheduler가 새 주문을 찾으면 고유한 인스턴스 ID를 가진 `LockedBy` 필드를 즉시 채우고 `CompleteBy` 필드를 적절한 시간에 설정하며 `ProcessState` 필드를 처리에 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-235">When the Scheduler finds a new order, it immediately populates the `LockedBy` field with its own instance ID, sets the `CompleteBy` field to an appropriate time, and sets the `ProcessState` field to processing.</span></span> <span data-ttu-id="03d77-236">코드는 Scheduler의 동시 인스턴스 두 개가 동시에 같은 주문을 처리하지 못하도록 단독성이며 원자성을 가지도록 설계됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-236">The code is designed to be exclusive and atomic to ensure that two concurrent instances of the Scheduler can't try to handle the same order simultaneously.</span></span>

<span data-ttu-id="03d77-237">그런 다음 Scheduler는 비즈니스 워크플로를 실행하여 주문을 비동기적으로 처리하여 상태 저장소의 `OrderID` 필드의 값을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-237">The Scheduler then runs the business workflow to process the order asynchronously, passing it the value in the `OrderID` field from the state store.</span></span> <span data-ttu-id="03d77-238">주문을 처리하는 워크플로는 주문 데이터베이스에서 주문 세부 정보를 검색하고 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-238">The workflow handling the order retrieves the details of the order from the orders database and performs its work.</span></span> <span data-ttu-id="03d77-239">주문 처리 워크플로의 단계가 원격 서비스를 호출해야 하는 경우 에이전트를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-239">When a step in the order processing workflow needs to invoke the remote service, it uses an Agent.</span></span> <span data-ttu-id="03d77-240">워크플로 단계는 요청/응답 채널 역할을 하는 한 쌍의 Azure Service Bus 메시지 큐를 사용하여 에이전트와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-240">The workflow step communicates with the Agent using a pair of Azure Service Bus message queues acting as a request/response channel.</span></span> <span data-ttu-id="03d77-241">그림은 솔루션의 상위 수준 보기를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-241">The figure shows a high level view of the solution.</span></span>

![그림 2 - Scheduler 에이전트 감독자 패턴을 사용하여 Azure 솔루션에서 주문 처리](./_images/scheduler-agent-supervisor-solution.png)

<span data-ttu-id="03d77-243">워크플로 단계에서 에이전트로 전송된 메시지는 주문을 설명하고 완료 제한 시간을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-243">The message sent to the Agent from a workflow step describes the order and includes the complete-by time.</span></span> <span data-ttu-id="03d77-244">에이전트가 완료 제한 시간이 만료되기 전에 원격 서비스로부터 응답을 받는 경우, 워크플로가 수신 중인 Service Bus 큐에서 회신 메시지를 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-244">If the Agent receives a response from the remote service before the complete-by time expires, it posts a reply message on the Service Bus queue on which the workflow is listening.</span></span> <span data-ttu-id="03d77-245">워크플로 단계가 유효한 회신 메시지를 받은 경우, 처리를 완료하고 Scheduler는 주문 상태의 \`ProcessState 필드를 처리됨으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-245">When the workflow step receives the valid reply message, it completes its processing and the Scheduler sets the \`ProcessState field of the order state to processed.</span></span> <span data-ttu-id="03d77-246">이 때 주문 처리가 성공적으로 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-246">At this point, the order processing has completed successfully.</span></span>

<span data-ttu-id="03d77-247">에이전트가 원격 서비스로부터 응답을 받기 전에 완료 제한 시간이 만료되면 에이전트는 간단히 처리를 중단하고 주문 처리를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-247">If the complete-by time expires before the Agent receives a response from the remote service, the Agent simply halts its processing and terminates handling the order.</span></span> <span data-ttu-id="03d77-248">마찬가지로, 주문을 처리하는 워크플로가 완료 제한 시간을 초과하면 역시 주문 처리를 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-248">Similarly, if the workflow handling the order exceeds the complete-by time, it also terminates.</span></span> <span data-ttu-id="03d77-249">두 경우 모두 상태 저장소의 주문 상태가 처리 중으로 설정되어 있지만 완료 제한 시간은 주문 처리 시간이 지났고 프로세스가 실패한 것으로 간주됨을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-249">In both cases, the state of the order in the state store remains set to processing, but the complete-by time indicates that the time for processing the order has passed and the process is deemed to have failed.</span></span> <span data-ttu-id="03d77-250">원격 서비스에 액세스하는 에이전트 또는 주문을 처리하는 워크플로(혹은 둘 다)가 예기치 않게 종료되는 경우, 상태 저장소의 정보는 다시 처리 중으로 설정되며 결국 만료된 완료 제한 값을 가지게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-250">Note that if the Agent that's accessing the remote service, or the workflow that's handling the order (or both) terminate unexpectedly, the information in the state store will again remain set to processing and eventually will have an expired complete-by value.</span></span>

<span data-ttu-id="03d77-251">에이전트가 원격 서비스에 연결하려는 동안 복구할 수 없고 지속적인 오류를 감지한 경우, 오류 응답을 워크플로로 다시 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-251">If the Agent detects an unrecoverable, nontransient fault while it's trying to contact the remote service, it can send an error response back to the workflow.</span></span> <span data-ttu-id="03d77-252">Scheduler는 주문 상태를 오류로 설정하고 이벤트를 발생시켜 운영자에게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-252">The Scheduler can set the status of the order to error and raise an event that alerts an operator.</span></span> <span data-ttu-id="03d77-253">그러면 운영자는 실패 원인을 직접 해결하고 실패한 처리 단계를 다시 제출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-253">The operator can then try to resolve the reason for the failure manually and resubmit the failed processing step.</span></span>

<span data-ttu-id="03d77-254">감독자는 상태 저장소를 정기적으로 검사하여 만료된 완료 제한 값을 가진 주문을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-254">The Supervisor periodically examines the state store looking for orders with an expired complete-by value.</span></span> <span data-ttu-id="03d77-255">감독자가 레코드를 찾으면 `FailureCount` 필드의 값을 올립니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-255">If the Supervisor finds a record, it increments the `FailureCount` field.</span></span> <span data-ttu-id="03d77-256">오류 개수 값이 지정된 임계 값 이하인 경우, 감독자는 `LockedBy` 필드를 null로 재설정하고, `CompleteBy` 필드를 새 만료 시간으로 업데이트하며, `ProcessState` 필드를 보류 중으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-256">If the failure count value is below a specified threshold value, the Supervisor resets the `LockedBy` field to null, updates the `CompleteBy` field with a new expiration time, and sets the `ProcessState` field to pending.</span></span> <span data-ttu-id="03d77-257">Scheduler의 인스턴스는 이 주문을 선택하고 이전처럼 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-257">An instance of the Scheduler can pick up this order and perform its processing as before.</span></span> <span data-ttu-id="03d77-258">오류 개수 값이 지정된 임계값을 초과하면 실패 원인은 지속적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-258">If the failure count value exceeds a specified threshold, the reason for the failure is assumed to be nontransient.</span></span> <span data-ttu-id="03d77-259">감독자는 주문 상태를 오류로 설정하고 이벤트를 발생시켜 운영자에게 알립니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-259">The Supervisor sets the status of the order to error and raises an event that alerts an operator.</span></span>

> <span data-ttu-id="03d77-260">이 예에서 감독자는 별도의 작업자 역할에서 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-260">In this example, the Supervisor is implemented in a separate worker role.</span></span> <span data-ttu-id="03d77-261">(이 패턴에서 스케줄러 구성 요소와 혼동하지 않기 위해) Azure Scheduler 서비스를 사용하여 실행할 감독자 작업을 조정하기 위해 다양한 전략을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-261">You can use a variety of strategies to arrange for the Supervisor task to be run, including using the Azure Scheduler service (not to be confused with the Scheduler component in this pattern).</span></span> <span data-ttu-id="03d77-262">Azure Scheduler 서비스에 대한 자세한 내용은 [스케줄러](https://azure.microsoft.com/services/scheduler/) 페이지를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="03d77-262">For more information about the Azure Scheduler service, visit the [Scheduler](https://azure.microsoft.com/services/scheduler/) page.</span></span>

<span data-ttu-id="03d77-263">이 예에는 표시되지 않았지만 Scheduler는 주문을 제출했던 응용 프로그램이 진행률과 주문 상태에 대해 계속 알려주도록 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-263">Although it isn't shown in this example, the Scheduler might need to keep the application that submitted the order informed about the progress and status of the order.</span></span> <span data-ttu-id="03d77-264">응용 프로그램과 Scheduler는 둘 사이의 종속성을 제거하기 위해 서로 격리됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-264">The application and the Scheduler are isolated from each other to eliminate any dependencies between them.</span></span> <span data-ttu-id="03d77-265">응용 프로그램은 어떤 Scheduler 인스턴스가 주문을 처리하는지 알지 못하며, Scheduler는 어떤 특정 응용 프로그램 인스턴스가 주문을 게시했는지 인식하지 못합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-265">The application has no knowledge of which instance of the Scheduler is handling the order, and the Scheduler is unaware of which specific application instance posted the order.</span></span>

<span data-ttu-id="03d77-266">주문 상태를 보고하도록 허용하기 위해 응용 프로그램은 자체의 전용 응답 큐를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-266">To allow the order status to be reported, the application could use its own private response queue.</span></span> <span data-ttu-id="03d77-267">이 응답 큐의 세부 정보는 상태 저장소에 이 정보를 포함하는 제출 프로세스로 보낸 요청의 일부로서 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-267">The details of this response queue would be included as part of the request sent to the submission process, which would include this information in the state store.</span></span> <span data-ttu-id="03d77-268">그런 다음 Scheduler는 주문 상태(요청 받음, 주문 완료됨, 주문 실패함 등)를 나타내는 이 큐에 메시지를 게시합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-268">The Scheduler would then post messages to this queue indicating the status of the order (request received, order completed, order failed, and so on).</span></span> <span data-ttu-id="03d77-269">응용 프로그램의 원본 요청과 관련될 수 있도록 주문 ID를 이들 메시지에 포함시켜야 합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-269">It should include the order ID in these messages so they can be correlated with the original request by the application.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="03d77-270">관련 패턴 및 지침</span><span class="sxs-lookup"><span data-stu-id="03d77-270">Related patterns and guidance</span></span>

<span data-ttu-id="03d77-271">이 패턴을 구현할 때 다음 패턴 및 지침도 관련이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-271">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>
- <span data-ttu-id="03d77-272">[다시 시도 패턴][retry-pattern].</span><span class="sxs-lookup"><span data-stu-id="03d77-272">[Retry pattern][retry-pattern].</span></span> <span data-ttu-id="03d77-273">에이전트는 이 패턴을 사용하여 이전에 실패했던 원격 서비스 또는 리소스에 액세스하는 작업을 투명하게 재시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-273">An Agent can use this pattern to transparently retry an operation that accesses a remote service or resource that has previously failed.</span></span> <span data-ttu-id="03d77-274">실패의 원인이 일시적이며 수정할 수 있다고 예상되는 경우 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-274">Use when the expectation is that the cause of the failure is transient and can be corrected.</span></span>
- <span data-ttu-id="03d77-275">[회로 차단기 패턴](circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="03d77-275">[Circuit Breaker pattern](circuit-breaker.md).</span></span> <span data-ttu-id="03d77-276">에이전트는 원격 서비스 또는 리소스에 연결했을 때 해결하는 데 시간이 다소 걸리는 오류를 처리하는 데 이 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-276">An Agent can use this pattern to handle faults that take a variable amount of time to correct when connecting to a remote service or resource.</span></span>
- <span data-ttu-id="03d77-277">[보상 트랜잭션 패턴](compensating-transaction.md).</span><span class="sxs-lookup"><span data-stu-id="03d77-277">[Compensating Transaction pattern](compensating-transaction.md).</span></span> <span data-ttu-id="03d77-278">Scheduler에 의해 수행되고 있는 워크플로를 성공적으로 완료할 수 없는 경우, 이전에 수행한 작업을 취소해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-278">If the workflow being performed by a Scheduler can't be completed successfully, it might be necessary to undo any work it's previously performed.</span></span> <span data-ttu-id="03d77-279">보상 트랜잭션 패턴은 최종 일관성 모델을 따라 작업에 대해 이를 어떻게 수행할 수 있는지를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-279">The Compensating Transaction pattern describes how this can be achieved for operations that follow the eventual consistency model.</span></span> <span data-ttu-id="03d77-280">이러한 유형의 작업은 일반적으로 복잡한 비즈니스 프로세스와 워크플로를 수행하는 Scheduler에 의해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-280">These types of operations are commonly implemented by a Scheduler that performs complex business processes and workflows.</span></span>
- <span data-ttu-id="03d77-281">[비동기 메시징 입문](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="03d77-281">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="03d77-282">Scheduler 에이전트 감독자 패턴의 구성 요소는 일반적으로 서로 분리되어 실행되고 비동기적으로 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-282">The components in the Scheduler Agent Supervisor pattern typically run decoupled from each other and communicate asynchronously.</span></span> <span data-ttu-id="03d77-283">메시지 큐에 따라 비동기 통신을 구현하는 데 사용할 수 있는 몇 가지 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-283">Describes some of the approaches that can be used to implement asynchronous communication based on message queues.</span></span>
- <span data-ttu-id="03d77-284">[리더 선택 패턴](leader-election.md).</span><span class="sxs-lookup"><span data-stu-id="03d77-284">[Leader Election pattern](leader-election.md).</span></span> <span data-ttu-id="03d77-285">실패한 동일 프로세스 복구를 시도하지 않도록 하기 위해 감독자의 여러 인스턴스 작업을 조정해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-285">It might be necessary to coordinate the actions of multiple instances of a Supervisor to prevent them from attempting to recover the same failed process.</span></span> <span data-ttu-id="03d77-286">리더 선택 패턴은 이를 수행하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="03d77-286">The Leader Election pattern describes how to do this.</span></span>
- <span data-ttu-id="03d77-287">Clemens Vasters 블로그의 [클라우드 아키텍처: Scheduler-에이전트-감독자 패턴](https://blogs.msdn.microsoft.com/clemensv/2010/09/27/cloud-architecture-the-scheduler-agent-supervisor-pattern/)</span><span class="sxs-lookup"><span data-stu-id="03d77-287">[Cloud Architecture: The Scheduler-Agent-Supervisor Pattern](https://blogs.msdn.microsoft.com/clemensv/2010/09/27/cloud-architecture-the-scheduler-agent-supervisor-pattern/) on Clemens Vasters' blog</span></span>
- [<span data-ttu-id="03d77-288">프로세스 관리자 패턴</span><span class="sxs-lookup"><span data-stu-id="03d77-288">Process Manager pattern</span></span>](http://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html)
- <span data-ttu-id="03d77-289">[참조 6: A Saga on Sagas](https://msdn.microsoft.com/library/jj591569.aspx).</span><span class="sxs-lookup"><span data-stu-id="03d77-289">[Reference 6: A Saga on Sagas](https://msdn.microsoft.com/library/jj591569.aspx).</span></span> <span data-ttu-id="03d77-290">CQRS 패턴이 프로세스 관리자 를 사용하는 방법을 보여주는 예입니다(CQRS Journey 지침의 일부).</span><span class="sxs-lookup"><span data-stu-id="03d77-290">An example showing how the CQRS pattern uses a process manager (part of the CQRS Journey guidance).</span></span>
- [<span data-ttu-id="03d77-291">Microsoft Azure Scheduler</span><span class="sxs-lookup"><span data-stu-id="03d77-291">Microsoft Azure Scheduler</span></span>](https://azure.microsoft.com/services/scheduler/)

[retry-pattern]: ./retry.md
