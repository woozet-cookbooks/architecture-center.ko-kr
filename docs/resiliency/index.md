---
title: Azure용 복원 응용 프로그램 디자인
description: Azure에서 고가용성 및 재해 복구를 제공하는 복원 응용 프로그램을 빌드하는 방법을 설명합니다.
author: MikeWasson
ms.date: 05/26/2017
ms.custom: resiliency
pnp.series.title: Design for Resiliency
ms.openlocfilehash: 9a6bd1332ea59923b32379018060403024b15e10
ms.sourcegitcommit: f665226cec96ec818ca06ac6c2d83edb23c9f29c
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/16/2018
ms.locfileid: "31012640"
---
# <a name="designing-resilient-applications-for-azure"></a>Azure용 복원 응용 프로그램 디자인

분산 시스템에서는 오류가 발생하기 마련입니다. 하드웨어 고장이 발생할 수 있습니다. 일시적인 네트워크 오류가 발생할 수 있습니다. 매우 드물게 서비스 또는 지역 전체가 중단될 수도 있지만 그렇다 하더라도 계획된 중단이어야 합니다. 

클라우드에서 신뢰할 수 있는 응용 프로그램을 빌드하는 것은 엔터프라이즈 환경에서 신뢰할 수 있는 응용 프로그램을 빌드하는 것과 다릅니다. 기존에는 규모 확장을 위해 고성능 하드웨어를 구입해야 했지만, 클라우드 환경에서는 강화 대신 규모 확장을 해야 합니다. 클라우드 환경의 비용은 상용 하드웨어를 사용하는 내내 낮은 수준으로 유지됩니다. 이 새로운 환경에서는 오류를 방지하고 "오류 간 평균 시간" 최적화에 중점을 두는 대신 "평균 복원 시간"에 집중합니다. 목표는 오류의 영향을 최소화하는 것입니다.

이 문서에서는 Microsoft Azure에서 복원 응용 프로그램을 빌드하는 방법에 대한 개요를 제공합니다. 먼저 *복원력*이라는 용어의 정의와 관련 개념부터 시작하겠습니다. 그런 다음 디자인 및 구현부터 배포 및 운영에 이르는 응용 프로그램의 전체 수명에 걸쳐 구조화된 방법을 사용하여 복원력을 달성하는 프로세스를 설명하겠습니다.

## <a name="what-is-resiliency"></a>복원력이란?
**복원력**은 오류를 복구하여 계속 작동하는 시스템 기능입니다. 오류 *방지*가 아니라 가동 중지 또는 데이터 손실을 방지하는 방법으로 오류에 *대응*하는 것입니다. 복원력의 목표는 오류가 발생한 후 응용 프로그램을 완전히 작동하는 상태로 되돌리기 위한 것입니다.

복원력의 두 가지 중요한 측면은 고가용성과 재해 복구입니다.

* **HA(고가용성)** 은 응용 프로그램이 심각한 가동 중지 없이 정상 상태로 계속 실행되는 기능입니다. "정상 상태"는 응용 프로그램에서 응답하고 사용자가 응용 프로그램에 연결하여 응용 프로그램과 상호 작용할 수 있음을 의미합니다.  
* **DR(재해 복구)** 은 드물지만 중요한 사고, 즉 전체 지역에 영향을 주는 서비스 중단과 같이 일시적이지 않은 대규모 장애로부터 복구할 수 있는 기능입니다. 재해 복구에는 데이터 백업 및 보관이 포함되며, 백업에서 데이터베이스를 복원하는 것과 같은 수동 작업이 포함될 수 있습니다.

HA와 DR을 구분하는 방법 중 하나로, DR은 오류의 영향이 HA 디자인의 오류 처리 능력을 초과할 때 시작됩니다.  

복원력을 디자인할 때 가용성 요구 사항을 이해해야 합니다. 허용되는 가동 중지 시간이 얼마나 됩니까? 이것은 비용 함수의 일종입니다. 가동 중지로 인한 잠재적 비용이 얼마나 발생할까요? 고가용성 응용 프로그램을 만들려면 얼마를 투자해야 할까요? 응용 프로그램을 사용할 수 있다는 것이 무슨 뜻인지도 정의해야 합니다. 예를 들어 고객이 주문을 제출할 수 있지만 시스템이 일반적인 시간 내에 처리할 수 없으면 "가동 중지"입니까? 특정 유형의 정전이 발생할 확률, 그리고 완화 전략이 비용 효율적인지 여부도 고려해야 합니다.

또 다른 일반적인 용어로 **BC(비즈니스 연속성)** 가 사용되고 있는데, 자연 재해나 서비스 중단 같은 악조건이 발생하는 동안 그리고 발생 후에 필수 비즈니스 기능을 수행하는 기능을 말합니다. 물리적 시설, 사람, 통신, 운송, IT를 포함한 기업의 전체 운영이 BC 범위에 포함됩니다. 이 문서에서는 클라우드 응용 프로그램을 집중적으로 다루지만, 전체적인 BC 요구 사항에 맞춰서 복원력 계획을 수행해야 합니다. 

**데이터 백업**은 DR의 중요한 부분입니다. 응용 프로그램의 상태 비저장 구성 요소가 실패하면 언제든지 다시 배포할 수 있습니다. 하지만 데이터가 손실되면 시스템은 안정적인 상태로 돌아갈 수 없습니다. 이상적으로 지역 수준의 재해 발생 시 다른 지역에 데이터를 백업해야 합니다. 

백업은 **데이터 복제**와 다릅니다. 시스템이 복제본을 신속하게 장애 조치할 수 있도록 데이터 복제는 근실시간으로 데이터를 복사합니다. 많은 데이터베이스 시스템은 복제를 지원합니다. 예를 들어 SQL Server는 SQL Server Always On 가용성 그룹을 지원합니다. 데이터의 복제본을 항상 준비함으로써 데이터 복제가 가동 중단으로부터 복구하는 데 걸리는 시간을 줄일 수 있습니다. 그러나 데이터 복제는 사용자 오류로부터 보호될 수 없습니다. 사용자 오류로 인해 데이터가 손상되면 손상된 데이터가 바로 복제본에 복사됩니다. 따라서 장기 백업을 DR 전략에 포함해야 합니다. 

## <a name="process-to-achieve-resiliency"></a>복원력을 구현하기 위한 프로세스
복원력은 추가 기능이 아닙니다. 시스템적으로 설계하여 운영 방식 속에 담아야 합니다. 다음은 일반적인 모델입니다.

1. **정의** - 비즈니스 요구에 따라 가용성 요구 사항을 정의합니다.
2. **디자인** - 복원력 있는 응용 프로그램을 디자인합니다. 검증된 사례를 따르는 아키텍처로 시작한 후 해당 아키텍처에서 발생 가능한 오류를 식별합니다.
3. **구현** - 오류를 감지하고 복구할 전략을 구현합니다. 
4. **테스트** - 오류를 시뮬레이션하고 강제 장애 조치(failover)를 트리거하여 구현된 전략을 테스트합니다. 
5. **배포** - 안정적이고 반복 가능한 프로세스를 사용하여 프로덕션 환경에 응용 프로그램을 배포합니다. 
6. **모니터링** - 응용 프로그램을 모니터링하여 오류를 감지합니다. 시스템을 모니터링하여 응용 프로그램 상태를 측정하고 필요할 때 사고에 대응할 수 있습니다. 
7. **대응** - 수동 개입이 필요한 문제가 있는 경우 적절하게 대응합니다.

이 문서의 나머지 부분에서는 이러한 각 단계를 좀 더 자세히 살펴보겠습니다.

## <a name="defining-your-resiliency-requirements"></a>복원력 요구 사항 정의
복원력 계획은 비즈니스 요구 사항으로 시작합니다. 다음과 같은 몇 가지 용어를 통해 복원력에 대해 생각해볼 수 있습니다.

### <a name="decompose-by-workload"></a>워크로드별로 분해
많은 클라우드 솔루션이 여러 응용 프로그램 워크로드로 구성되어 있습니다. 여기서 "워크로드"라는 용어는 별개의 기능 또는 계산 작업을 의미하며, 비즈니스 논리와 데이터 저장소 요구 사항의 측면에서 다른 작업과 논리적으로 분리할 수 있습니다. 예를 들어 전자 상거래 앱에는 다음과 같은 워크로드가 포함될 수 있습니다.

* 제품 카탈로그를 찾아보고 검색합니다.
* 주문을 작성하고 추적합니다.
* 추천 제품을 살펴봅니다.

이러한 워크로드마다 가용성, 확장성, 데이터 일관성, 재해 복구 등에 대한 요구 사항이 서로 다를 수 있습니다. 다시 말씀드리지만, 이것은 비즈니스적인 의사 결정입니다.

사용 패턴도 고려해야 합니다. 시스템이 반드시 작동해야 하는 특정 중요 시간대가 있습니까? 예를 들어 세금 신고 서비스는 신고 마감 직전에는 절대 중지되면 안 되고, 비디오 스트리밍 서비스는 대형 스포츠 행사가 진행되는 내내 작동해야 합니다. 이처럼 중요한 기간에는 여러 지역에 걸쳐 이중으로 배포하면 한 지역에서 오류가 발생하더라도 응용 프로그램을 장애 조치(failover)할 수 있습니다. 그러나 다중 지역 배포는 더 많은 비용이 들기 때문에 덜 중요한 시간에는 한 지역에서만 응용 프로그램을 실행할 수도 있습니다.

### <a name="rto-and-rpo"></a>RTO 및 RPO
고려해야 할 두 가지 중요한 메트릭으로 복구 시간 목표와 복구 지점 목표가 있습니다.

* **RTO(복구 시간 목표)** 는 사고 발생 후 응용 프로그램 중단이 허용되는 최대 시간입니다. RTO가 90분이면 재해가 시작된 시점부터 90분 이내에 응용 프로그램을 실행 상태로 복원할 수 있어야 합니다. RTO가 매우 낮은 경우 지역 단위 정전에 대비하여 항상 대기 중인 보조 배포를 실행할 수 있습니다.

* **RPO(복구 지점 목표)** 는 재해 발생 시 허용되는 최대 데이터 손실 기간입니다. 예를 들어 다른 데이터베이스에 데이터를 복제하지 않고 단일 데이터베이스에만 데이터를 저장하며 매시간 백업을 수행하는 경우 최대 1시간 분량의 데이터가 손실될 수 있습니다. 

RTO 및 RPO는 비즈니스 요구 사항입니다. 위험 평가를 수행하면 응용 프로그램의 RTO 및 RPO를 정의하는 데 도움이 될 수 있습니다. 또 다른 일반적인 메트릭인 **MTTR(평균 복구 시간)** 은 오류 발생 후 응용 프로그램을 복원하는 데 걸리는 평균 시간입니다. MTTR은 시스템에 대한 실증적 팩트입니다. MTTR이 RTO를 초과하면 시스템에 오류가 발생했을 때 정의된 RTO 내에서 시스템을 복원할 수 없기 때문에 허용할 수 없는 수준의 비즈니스 중단이 발생합니다. 

### <a name="slas"></a>SLA
Azure에서 [Service Level Agreement(서비스 수준 약정)][sla]는 작동 시간 및 연결에 대한 Microsoft의 정책을 설명합니다. 특정 서비스의 SLA가 99.9%라는 것은 시간의 99.9% 동안 서비스를 사용할 수 있다는 의미입니다.

> [!NOTE]
> Azure SLA에는 각 서비스의 "가용성"에 대한 구체적인 정의와 함께 SLA가 충족되지 않은 경우 서비스 크레딧을 제공하는 조항도 포함되어 있습니다. SLA의 이러한 측면은 적용 정책의 역할을 합니다. 
> 
> 

개발자는 솔루션의 각 워크로드에 대한 고유의 목표 SLA를 정의해야 합니다. SLA를 사용하면 아키텍처가 비즈니스 요구 사항을 충족하는지 평가할 수 있습니다. 예를 들어 어떤 워크로드가 99.99% 작동 시간을 요구하지만 SLA 99.9% 서비스를 사용하는 경우 해당 서비스는 시스템에서 단일 오류 지점이 될 수 없습니다. 한 가지 해결책은 서비스 오류를 대비하여 대체 경로를 만들거나, 다른 조치를 수행하여 해당 서비스의 오류를 복구하는 것입니다. 

다음 표는 다양한 SLA 수준의 잠재적인 누적 가동 중지 시간을 보여 줍니다. 

| SLA | 주간 가동 중지 시간 | 월간 가동 중지 시간 | 연간 가동 중지 시간 |
| --- | --- | --- | --- |
| 99% |1.68시간 |7.2시간 |3.65일 |
| 99.9% |10.1분 |43.2분 |8.76시간 |
| 99.95% |5분 |21.6분 |4.38시간 |
| 99.99% |1.01분 |4.32분 |52.56분 |
| 99.999% |6초 |25.9초 |5.26분 |

다른 요소가 전부 동일하다면 당연히 가용성이 높을수록 좋습니다. 그러나 9의 수를 늘리려면 그에 따른 비용과 복잡성도 함께 증가합니다. 작동 시간이 99.99%이면 총 월간 가동 중지 시간이 약 5분입니다. 99.999%를 달성하기 위해 추가적인 복잡성과 비용을 감수할 가치가 있습니까? 대답은 비즈니스 요구 사항에 따라 다릅니다. 

다음은 SLA를 정의할 때 고려해야 할 다른 사항입니다.

* 4개의 9(99.99%)를 달성하려면 아마도 수동 개입에 의존한 오류 복구로는 불가능할 것입니다. 응용 프로그램이 자체적으로 진단하고 자체적으로 복구해야 합니다. 
* 9의 수가 4개를 넘어가면 SLA를 충족할 만큼 신속하게 가동 중단을 감지하기가 쉽지 않습니다.
* SLA가 측정되는 시간을 생각해 보세요. 시간이 짧을수록 허용 오차도 작습니다. SLA를 시간별 또는 일별 작동 시간으로 정의할 수가 없습니다. 

### <a name="composite-slas"></a>복합 SLA
Azure SQL Database에 쓰는 App Service 웹앱을 고려해 보세요. 이 문서가 작성된 시점에 이러한 Azure 서비스의 SLA는 다음과 같습니다.

* App Service Web Apps = 99.95%
* SQL Database = 99.99%

![복합 SLA](./images/sla1.png)

이 응용 프로그램에 기대하는 최대 가동 중지 시간이 얼마입니까? 서비스 중 하나가 중단되면 전체 응용 프로그램이 중단됩니다. 일반적으로 각 서비스가 중단될 확률은 독립적이므로 이 응용 프로그램의 복합 SLA는 99.95% &times; 99.99% = 99.94%입니다. 개별 SLA보다 낮은데, 별로 놀랄 일은 아닙니다. 여러 서비스를 사용하는 응용 프로그램은 잠재적 오류 지점이 더 많기 때문입니다. 

반면, 독립적인 대체 경로를 만들어서 복합 SLA를 높일 수 있습니다. 예를 들어 SQL Database를 사용할 수 없으면 트랜잭션을 큐에 배치하여 나중에 처리할 수 있습니다.

![복합 SLA](./images/sla2.png)

이 디자인에서는 응용 프로그램이 데이터베이스에 연결할 수 없는 경우에도 계속 사용할 수 있습니다. 그러나 데이터베이스와 큐가 동시에 중단되면 응용 프로그램도 중단됩니다. 예상되는 동시 중단 시간 비율은 0.0001 &times; 0.001이므로 이 복합 경로의 복합 SLA는 다음과 같습니다.  

* 데이터베이스 또는 큐 = 1.0 &minus; (0.0001 &times; 0.001) = 99.99999%

총 복합 SLA는 다음과 같습니다.

* 웹앱 및 (데이터베이스 또는 큐) = 99.95% &times; 99.99999% = ~99.95%

하지만 이 방법에는 단점이 있습니다. 응용 프로그램 논리가 더 복잡하고 큐에 대한 비용을 지불해야 하며, 데이터 일관성 문제를 고려해야 할 수도 있습니다.

**다중 지역 배포의 SLA**. 또 다른 HA 기술은 여러 지역에 응용 프로그램을 배포 하고, 한 지역의 응용 프로그램에 오류가 발생하면 Azure Traffic Manager를 사용하여 장애 조치(failover)하는 것입니다. 2지역 배포의 경우 복합 SLA는 다음과 같이 계산합니다. 

한 지역에 배포된 응용 프로그램의 SLA를 *N*이라 하겠습니다. 두 지역의 응용 프로그램이 동시에 중단될 예상 가능성은 (1 &minus; N) &times; (1 &minus; N)입니다. 따라서

* 두 지역의 복합 SLA = 1 &minus; (1 &minus; N)(1 &minus; N) = N + (1 &minus; N)N입니다.

마지막으로, [Traffic Manager SLA][tm-sla]를 고려해야 합니다. 이 문서가 작성된 시점의 Traffic Manager SLA는 99.99%입니다.

* 복합 SLA = 99.99% &times;(두 지역의 SLA를 결합)

또한 장애 조치(failover)가 즉시 이루어지는 것이 아니기 때문에 장애 조치(failover) 중에 약간의 가동 중지 시간이 있을 수 있습니다. 자세한 내용은 [Traffic Manager 엔드포인트 모니터링 및 장애 조치(failover)][tm-failover]를 참조하세요.

계산된 SLA 숫자는 유용한 기본 자료이지만 가용성에 대한 전반적인 성능을 알려주지는 않습니다. 종종 중요하지 않은 경로에 오류가 발생할 때 응용 프로그램 성능이 정상적으로 저하될 수 있습니다. 책 카탈로그를 표시하는 응용 프로그램을 생각해 보세요. 이 응용 프로그램은 표지의 썸네일 이미지를 검색할 수 없으면 자리 표시자 이미지를 표시할 것입니다. 이 경우, 이미지를 가져오지 못해도 사용자 경험에는 영향을 주지만 응용 프로그램의 작동 시간에는 영향을 주지 않습니다.  

## <a name="redundancy-and-designing-for-failure"></a>오류에 대한 중복성 및 디자인

오류는 해당 영향의 범위가 다를 수 있습니다. 실패한 디스크와 같은 일부 하드웨어 오류는 단일 호스트 컴퓨터에 영향을 줄 수 있습니다. 실패한 네트워크 스위치는 전체 서버 랙에 영향을 줄 수 있습니다. 데이터 센터의 전원 손실 등 전체 데이터 센터를 방해하는 오류는 일반적이지 않습니다. 가끔 전체 지역을 사용할 수 없게 될 수 있습니다.

중복성을 통해 응용 프로그램을 복원력 있게 만들 수 있습니다. 그러나 응용 프로그램을 디자인할 때 이러한 중복성에 대해 계획해야 합니다. 또한 필요한 중복성 수준은 비즈니스 요구 사항에 따라 달라집니다. &mdash; 지역 가동 중단으로부터 보호하기 위해 일부 응용 프로그램에 지역 간 중복성이 필요합니다. 일반적으로 중복성과 안정성 및 비용과 복잡성 간에 균형을 조절해야 합니다.  

Azure에는 개별 VM에서 전체 영역에 이르는 모든 오류 수준에서 응용 프로그램이 중복되는 여러 기능이 있습니다. 

![](./images/redundancy.svg)

**단일 VM** Azure에서는 단일 VM에 작동 시간 SLA를 제공합니다. 둘 이상의 VM을 실행하여 SLA를 높일 수 있지만 단일 VM은 일부 워크로드에서 충분히 안정적일 수 있습니다. 프로덕션 워크로드의 경우 중복성을 위해 둘 이상의 VM을 사용하는 것이 좋습니다. 

**가용성 집합**. 디스크 또는 네트워크 전환이 실패한 경우 하드웨어 오류로부터 보호하려면 가용성 집합에 둘 이상의 VM을 배포합니다. 가용성 집합은 공통 전원 소스 및 네트워크 스위치를 공유하는 두 개 이상의 *장애 도메인*으로 구성됩니다. 가용성 집합의 VM은 장애 도메인에 분산되어 있으므로 하드웨어 오류가 하나의 장애 도메인에 영향을 주는 경우 네트워크 트래픽은 다른 오류 도메인에서 VM을 라우팅할 수 있습니다. 가용성 집합에 대한 자세한 내용은 [Azure에서 Windows 가상 머신의 가용성 관리](/azure/virtual-machines/windows/manage-availability)를 참조하세요.

**가용성 영역**.  가용성 영역은 Azure 지역 내에서 물리적으로 별도 영역입니다. 각 가용성 영역에는 고유한 소스, 네트워크 및 냉각 장치가 있습니다. 가용성 영역 간에 VM을 배포하면 데이터 센터 전체의 오류로부터 응용 프로그램을 보호할 수 있습니다. 

**쌍을 이루는 지역** 지역 가동 중단으로부터 응용 프로그램을 보호하려면 인터넷 트래픽을 서로 다른 지역에 배포하기 위해 Azure Traffic Manager를 사용하여 응용 프로그램을 여러 지역에 배포할 수 있습니다. 각 Azure 지역은 다른 지역과 쌍을 이룹니다. 이러한 지역은 함께 [지역 쌍](/azure/best-practices-availability-paired-regions)을 구성합니다. 브라질 남부를 제외하고 지역 쌍은 세금 및 법률 집행 관할 구역의 데이터 상주 요구 사항을 충족하기 위해 동일한 지리적 위치 내에 위치합니다.

다중 지역 응용 프로그램을 디자인할 때 지역 간 네트워크 대기 시간이 지역 내 네트워크 대기 시간보다 길다는 점을 고려해야 합니다. 예를 들어 장애 조치할 수 있도록 데이터베이스를 복제하는 경우 지역 간의 비동기 데이터 복제가 아니라 지역 내의 동기 데이터 복제를 사용합니다.

| &nbsp; | 가용성 집합 | 가용성 영역 | 쌍을 이루는 지역 |
|--------|------------------|-------------------|---------------|
| 오류의 범위 | 랙 | 데이터 센터 | 지역 |
| 요청 라우팅 | Load Balancer | 영역 간 부하 분산 장치 | Traffic Manager |
| 네트워크 대기 시간 | 매우 낮음 | 낮음 | 중간부터 높음 |
| 가상 네트워크  | VNet | VNet | 지역 간 VNet 피어링 |

## <a name="designing-for-resiliency"></a>복원력을 위한 디자인
디자인 단계에서 FMA(오류 모드 분석)를 수행해야 합니다. FMA의 목표는 가능한 실패 지점을 식별하고 응용 프로그램이 이러한 오류에 대응하는 방식을 정의하는 것입니다.

* 응용 프로그램이 이러한 종류의 오류를 어떻게 감지하나요?
* 응용 프로그램이 이러한 종류의 오류에 어떻게 대응하나요?
* 이러한 종류의 오류를 어떻게 로깅하고 모니터링하나요? 

Azure에 대한 구체적인 권장 사항을 비롯한 FMA 프로세스에 대한 자세한 내용은 [Azure 복원력 지침: 오류 모드 분석][fma]을 참조하세요.

### <a name="example-of-identifying-failure-modes-and-detection-strategy"></a>오류 모드 식별 및 감지 전략의 예
**실패 지점:** 외부 웹 서비스/API에 대한 호출입니다.

| 오류 모드 | 감지 전략 |
| --- | --- |
| 서비스를 사용할 수 없음 |HTTP 5xx |
| 제한 |HTTP 429(요청이 너무 많음) |
| 인증 |HTTP 401(권한 없음) |
| 느린 응답 시간 |요청 시간 초과 |

## <a name="resiliency-strategies"></a>복원력 전략
이 섹션에서는 몇 가지 일반적인 복원력 전략에 대한 설문 조사를 제공합니다. 이들 중 대부분은 특정 기술에 제한되지 않습니다. 이 섹션에서는 각 기술의 밑바탕에 깔려 있는 일반적인 개념을 설명하고 추가 정보에 대한 링크를 제공합니다.

### <a name="retry-transient-failures"></a>일시적인 오류 다시 시도
서비스 사용량이 많을 때 일시적인 네트워크 연결 해제, 데이터베이스 연결 끊김 또는 시간 제한으로 인해 일시적 오류가 발생할 수 있습니다. 일시적인 오류는 요청을 다시 시도하면 해결되는 경우가 자주 있습니다. 여러 Azure 서비스의 경우 클라이언트 SDK는 호출자에게 투명한 방식으로 자동 다시 시도를 구현합니다. 자세한 내용은 [다시 시도 서비스별 지침][retry-service-specific guidance]을 참조하세요.

각 다시 시도는 총 대기 시간에 추가됩니다. 또한 실패한 요청 수가 너무 많으면 보류 중인 요청이 큐에 누적되어 병목 상태가 발생할 수 있습니다. 이처럼 차단된 요청이 메모리, 스레드, 데이터베이스 연결 등의 중요한 시스템 리소스를 계속 잡아 두어 연속 오류를 일으킬 있습니다. 이 문제를 방지하려면 각 다시 시도 사이의 지연 시간을 늘리고 총 실패한 요청 수를 제한하세요.

![복합 SLA](./images/retry.png)

자세한 내용은 [다시 시도 패턴][retry-pattern]을 참조하세요.

### <a name="load-balance-across-instances"></a>인스턴스 간에 부하 분산
확장성을 위해 클라우드 응용 프로그램은 인스턴스를 추가하여 규모 확장할 수 있어야 합니다. 이 방법은 회전 대상에서 비정상 인스턴스를 제거할 수 있으므로 복원력도 향상됩니다.  

예: 

* 부하 분산 장치 뒤에 둘 이상의 VM을 배치합니다. 부하 분산 장치는 모든 VM에 트래픽을 분산합니다. [부하가 분산된 VM을 실행하여 확장성 및 가용성 확보][ra-multi-vm]를 참조하세요.
* Azure App Service 앱을 여러 인스턴스로 규모 확장합니다. App Service는 자동으로 인스턴스 간에 부하를 분산합니다. [기본 웹 응용 프로그램][ra-basic-web]을 참조하세요.
* [Azure Traffic Manager][tm]를 사용하여 엔드포인트 집합에 트래픽을 분산합니다.

### <a name="replicate-data"></a>데이터 복제
데이터 복제는 데이터 저장소의 일시적이지 않은 오류를 처리하는 일반적인 전략입니다. Azure SQL Database, Cosmos DB, Apache Cassandra를 포함한 많은 저장소 기술이 기본적으로 복제 기능을 제공합니다.  

읽기 및 쓰기 경로를 모두 고려해야 합니다. 저장소 기술에 따라 여러 개의 쓰기 가능한 복제본이 생길 수도 있고, 쓰기 가능한 복제본 하나와 읽기 전용 복제본 여러 개가 생길 수도 있습니다. 

가용성을 최대화하기 위해 복제본을 여러 영역에 배치할 수 있습니다. 그러나 데이터를 복제할 때 대기 시간이 증가하게 됩니다. 일반적으로 지역 간 복제는 비동기적으로 수행되며, 이는 복제본 오류가 발생할 경우 궁극적으로 일관성 모델 및 데이터 손실 가능성이 있다는 의미입니다. 

### <a name="degrade-gracefully"></a>정상적으로 성능 저하
서비스에 오류가 발생하고 장애 조치(failover) 경로가 없는 경우 응용 프로그램이 정상적으로 성능을 내리고 계속해서 허용 가능한 수준의 사용자 환경을 제공할 수 있습니다. 예: 

* 나중에 처리하도록 작업 항목을 큐에 배치합니다. 
* 예상 값을 반환합니다.
* 로컬로 캐시된 데이터를 사용합니다. 
* 사용자에게 오류 메시지를 표시합니다. (요청에 대응하여 응용 프로그램을 중지하는 것보다는 이 옵션이 낫습니다.)

### <a name="throttle-high-volume-users"></a>대규모 사용자 제한
소수의 사용자가 과도한 로드를 생성하는 경우가 가끔 있습니다. 이 경우 응용 프로그램의 가용성을 떨어트려 다른 사용자에게 영향을 줄 수입니다.

단일 클라이언트가 과도한 요청을 만드는 경우 응용 프로그램에서 클라이언트를 일정 기간 동안 제한할 수 있습니다. 제한 기간 동안 응용 프로그램은 해당 클라이언트의 요청 중 일부 또는 전부를 거부합니다(정확한 제한 전략에 따라). 제한의 임계값은 고객의 서비스 계층에 따라 달라질 수 있습니다. 

제한은 반드시 클라이언트가 악의적으로 작동했다는 의미가 아니라 서비스 할당량을 초과한다는 의미입니다. 경우에 따라 소비자가 지속적으로 할당량을 초과하거나 악의적으로 행동할 수 있습니다. 이 경우 더 나아가서 해당 사용자를 차단할 수 있습니다. 일반적으로 사용자 차단은 API 키 또는 IP 주소 범위를 차단하여 수행됩니다.

자세한 내용은 [제한 패턴][throttling-pattern]을 참조하세요.

### <a name="use-a-circuit-breaker"></a>회로 차단기 사용
회로 차단기 패턴은 응용 프로그램이 실패 가능성이 있는 작업을 반복해서 다시 시도하지 않도록 차단할 수 있습니다. 회로가 과부하가 흐르면 전류 흐름을 차단하는 물리적 회로 차단기와 비슷한 원리입니다.

회로 차단기는 서비스에 대한 호출을 래핑합니다. 다음과 같은 세 가지 상태가 있습니다.

* **닫힘**. 정상 상태입니다. 회로 차단기는 서비스에 요청을 보내고, 카운터는 최근 실패 수를 추적합니다. 실패 횟수가 지정된 기간 내에서 임계값을 초과하면 회로 차단기가 열림 상태로 전환됩니다. 
* **열림**. 이 상태에서는 회로 차단기가 서비스를 호출하지 않고 즉시 모든 요청을 실패로 처리합니다. 응용 프로그램은 복제본에서 데이터를 읽거나 사용자에게 오류만 반환하는 것처럼 완화 경로를 사용해야 합니다. 회로 차단기는 열림으로 전환될 때 타이머를 시작합니다. 타이머가 만료되면 회로 차단기가 반 열림 상태로 전환됩니다.
* **반 열림**. 이 상태에서는 회로 차단기가 제한된 수의 요청만 서비스로 보냅니다. 요청이 성공하면 서비스가 복구된 것으로 추정할 수 있으며, 회로 차단기가 닫힘 상태로 전환됩니다. 요청이 실패하면 다시 열림 상태로 돌아갑니다. 반 열림 상태는 복구 중인 서비스에 갑자기 요청이 몰리는 것을 방지합니다.

자세한 내용은 [회로 차단기 패턴][circuit-breaker-pattern]을 참조하세요.

### <a name="use-load-leveling-to-smooth-out-spikes-in-traffic"></a>부하 평준화를 사용하여 트래픽 급증을 매끄럽게 처리
백 엔드의 서비스가 감당할 수 없을 정도로 응용 프로그램의 트래픽이 갑자기 치솟을 수 있습니다. 백 엔드 서비스가 요청에 충분히 신속하게 응답할 수 없는 경우 요청이 큐에 추가되거나(백업) 서비스가 응용 프로그램을 제한할 수 있습니다.

큐를 버퍼로 사용하면 이 상황을 방지할 수 있습니다. 새 작업 항목이 있으면 백 엔드 서비스를 즉시 호출하는 대신 응용 프로그램이 작업 항목을 비동기적으로 실행되도록 큐에 추가합니다. 큐는 피크 부하를 매끄럽게 하는 버퍼 역할을 합니다. 

자세한 내용은 [큐 기반 부하 평준화 패턴][load-leveling-pattern]을 참조하세요.

### <a name="isolate-critical-resources"></a>중요한 리소스 격리
가끔 한 하위 시스템의 오류가 원인이 되어 응용 프로그램의 다른 부분에서 오류가 발생하기도 합니다. 오류가 스레드 또는 소켓 같은 리소스를 적시에 놓아주지 않으면 리소스가 고갈되어 이와 같은 상황이 발생할 수 있습니다. 

이 상황을 방지하려면 한 파티션의 오류 때문에 전체 시스템이 중단되는 일이 없도록 시스템을 격리된 그룹으로 분할하면 됩니다. 이 기술을 격벽 패턴이라고도 합니다.

예제:

* 데이터베이스를 분할하고(예를 들어 테넌트 기준으로 분할) 각 파티션에 대한 별도의 웹 서버 인스턴스 풀을 할당합니다.  
* 별도의 스레드 풀을 사용하여 호출을 서로 다른 서비스에 격리합니다. 이렇게 하면 서비스 중 하나가 실패하더라도 연쇄 오류가 발생하지 않도록 방지하는 데 도움이 됩니다. 예제는 Netflix [Hystrix 라이브러리][hystrix]를 참조하세요.
* [컨테이너][containers]를 사용하여 특정 하위 시스템에만 리소스를 제공하도록 제한합니다. 

![복합 SLA](./images/bulkhead.png)

### <a name="apply-compensating-transactions"></a>보정 트랜잭션 적용
보정 트랜잭션은 완료된 다른 트랜잭션의 효과를 실행 취소하는 트랜잭션입니다.

분산 시스템에서 강력한 트랜잭션 일관성을 달성하기가 매우 어려울 수 있습니다. 보정 트랜잭션은 각 단계에서 실행 취소할 수 있는 더 작은 일련의 개별 트랜잭션을 사용하여 일관성을 확보하는 방법입니다.

예를 들어 출장을 준비하려면 고객은 자동차, 호텔 객실 및 항공편을 예약해야 합니다. 이러한 단계 중 하나라도 실패하면 전체 작업이 실패합니다. 전체 작업에 단일 분산 트랜잭션을 사용하는 대신, 각 단계에 대한 보정 트랜잭션을 정의할 수 있습니다. 예를 들어 자동차 예약을 실행 취소하려면 예약을 취소하면 됩니다. 전체 작업을 완료하기 위해 코디네이터는 각 단계를 실행합니다. 어느 단계가 실패하면 코디네이터가 보정 트랜잭션을 적용하여 완료된 단계를 실행 취소합니다. 

자세한 내용은 [보정 트랜잭션 패턴][compensating-transaction-pattern]을 참조하세요. 


## <a name="testing-for-resiliency"></a>복원력 테스트
일반적으로 응용 프로그램의 기능을 테스트하는 방법과 동일한 방법으로는(단위 테스트 등을 실행) 복원력을 테스트할 수 없습니다. 그 대신, 간헐적으로 발생하는 오류 조건 하에서 종단 간 워크로드가 수행되는 방식을 테스트해야 합니다.

테스트는 반복적인 프로세스입니다. 응용 프로그램을 테스트하고, 결과를 측정하고, 결과를 분석 및 해결하고, 다시 프로세스를 반복합니다.

**오류 주입 테스트**. 실제 오류를 트리거하거나 시뮬레이션하여 오류 시 시스템 복원력을 테스트합니다. 다음은 테스트에 자주 사용되는 몇 가지 일반적인 오류 시나리오입니다.

* VM 인스턴스가 중단됩니다.
* 프로세스가 충돌합니다.
* 인증서가 만료됩니다.
* 액세스 키가 변경됩니다.
* 도메인 컨트롤러에서 DNS 서비스를 중단합니다.
* RAM 또는 스레드 수 같은 가용 시스템 리소스를 제한합니다.
* 디스크를 탑재 해제합니다.
* VM을 다시 배포합니다.

복구 시간을 측정하고 비즈니스 요구 사항이 충족되었는지 확인합니다. 오류 모드를 조합하여 테스트합니다. 오류가 연쇄적으로 발생하지 않아야 하며, 오류를 격리된 방식으로 처리해야 합니다.

이러한 이유로 디자인 단계에서 잠재적인 실패 지점을 분석하는 것이 매우 중요합니다. 분석 결과를 테스트 계획에 입력해야 합니다.

**부하 테스트**. [Visual Studio Team Services][vsts] 또는 [Apache JMeter][jmeter] 같은 도구를 사용하여 응용 프로그램의 부하 테스트를 수행합니다. 부하 테스트는 백 엔드 데이터베이스 성능 초과나 서비스 제한처럼 부하 상태에서만 발생하는 오류를 식별하는 데 있어서 매우 중요합니다. 프로덕션 데이터와 최대한 비슷한 프로덕션 데이터 또는 가상 데이터를 사용하여 최대 부하를 테스트합니다. 응용 프로그램이 실제 조건에서 어떻게 동작하는지 확인하는 것이 목표입니다.   

## <a name="resilient-deployment"></a>복원력 있는 배포
응용 프로그램이 프로덕션 환경에 배포된 후에는 업데이트로 인해 오류가 발생할 수 있습니다. 최악의 경우 잘못된 업데이트 때문에 가동이 중지될 수 있습니다. 이를 방지하려면 배포 프로세스가 예측 가능하고 반복 가능해야 합니다. 배포에는 Azure 리소스를 프로비전하고, 응용 프로그램 코드를 배포하고, 구성 설정을 적용하는 것이 포함됩니다. 업데이트에 세 가지가 모두 관련될 수도 있고 일부만 관련될 수도 있습니다. 

중요한 점은, 수동 배포는 오류가 발생하기 쉽다는 것입니다. 따라서 요청이 있을 때 실행할 수 있고 오류가 발생하면 다시 실행할 수 있는 자동화된 멱등원(idempotent) 프로세스를 사용하는 것이 좋습니다. 

* Resource Manager 템플릿을 사용하여 Azure 리소스의 프로비전을 자동화하세요.
* [Azure Automation DSC(Desired State Configuration)][dsc]를 사용하여 VM을 구성하세요.
* 응용 프로그램 코드에 자동화 배포 프로세스를 사용하세요.

복원력 있는 배포와 관련된 두 가지 개념은 *코드로써의 인프라* 및 *변경이 불가능한 인프라*입니다.

* **코드로써의 인프라**는 인프라를 프로비전하고 구성하기 위한 코드 사용 관행입니다. 코드로써의 인프라는 선언적 방법 또는 명령적 방법(또는 두 가지 조합)을 사용할 수 있습니다. Resource Manager 템플릿은 선언적 방법의 예입니다. PowerShell 스크립트는 명령적 방법의 예입니다.
* **변경이 불가능한 인프라**는 프로덕션 환경에 인프라가 배포된 후에는 인프라를 수정하면 안 된다는 원칙입니다. 그렇지 않으면 임시 변경 작업이 수행되어 무엇이 변경되었는지 정확하게 알기 어렵고 시스템에 대해 추론하기 어려운 상태에 빠질 수 있습니다. 

또 다른 문제는 응용 프로그램 업데이트를 수행하는 방법입니다. 잘못된 배포의 악영향을 최소화할 수 있도록 정교하게 통제되는 방식으로 업데이트를 푸시하는 청록색 배포 또는 카나리아 릴리스 같은 기술을 사용하는 것이 좋습니다.

* [청록색 배포][blue-green]는 실시간 응용 프로그램과 분리된 프로덕션 환경에 업데이트를 배포하는 기술입니다. 배포의 유효성을 검사한 후에는 업데이트된 버전으로 트래픽 라우팅을 전환합니다. 예를 들어 Azure App Service Web Apps는 스테이징 슬롯을 사용하여 이를 지원합니다.
* [카나리아 릴리스][canary-release]는 청록색 배포와 비슷합니다. 모든 트래픽을 업데이트된 버전으로 전환하는 대신, 트래픽의 일부를 새 배포로 라우팅하여 일부 사용자에게만 업데이트를 수행합니다. 문제가 있으면 업데이트를 중단하고 이전 배포를 되돌립니다. 문제가 없으면 트래픽 100%에 도달할 때까지 점점 더 많은 트래픽을 새 버전으로 라우팅합니다.

어떤 방법을 사용하든, 새 버전이 작동하지 않는 경우 마지막으로 알려진 정상 배포로 롤백할 수 있습니다. 또한 오류가 발생하면 어떤 버전 때문에 오류가 발생했는지 응용 프로그램 로그를 보고 알 수 있어야 합니다. 

## <a name="monitoring-and-diagnostics"></a>모니터링 및 진단
모니터링 및 진단은 복원력에 매우 중요한 요소입니다. 오류가 발생하면 오류가 있다는 사실을 알 수 있어야 하고 오류 원인을 파악할 수 있어야 합니다. 

대규모 분산 시스템을 모니터링하는 것은 상당한 과제입니다. 수십 개의 VM에서 실행되는 응용 프로그램이 있다고 생각해 봅시다. 각 VM에 한 번에 하나씩 로그인하여 로그 파일을 살펴보고 문제를 해결하는 것은 현실적이지 않습니다. 뿐만 아니라 VM 인스턴스의 수는 고정적이지 않습니다. 응용 프로그램이 규모 감축 또는 확장되면 VM이 추가 또는 제거되며, 인스턴스가 실패하여 다시 프로비전해야 하는 경우가 가끔 있습니다. 또한 일반적인 클라우드 응용 프로그램은 여러 데이터 저장소(Azure 저장소, SQL Database, Cosmos DB, Redis 캐시)를 사용할 수 있으며, 단일 사용자 작업이 여러 하위 시스템에 걸쳐 이어질 수 있습니다. 

모니터링 및 진단 프로세스를 여러 개별 단계로 구성된 파이프라인이라고 생각하면 됩니다.

![복합 SLA](./images/monitoring.png)

* **계측**. 모니터링 및 진단에 사용되는 원시 데이터는 응용 프로그램 로그, 웹 서버 로그, OS 성능 카운터, 데이터베이스 로그, Azure 플랫폼에 기본 제공되는 진단 기능을 포함하여 다양한 소스에서 가져옵니다. 대부분의 Azure 서비스는 문제의 원인을 파악하는 데 사용할 수 있는 진단 기능을 제공합니다.
* **수집 및 저장**. 원시 계측 데이터는 다양한 위치에 다양한 형식으로 저장할 수 있습니다(예: 응용 프로그램 추적 로그, IIS 로그, 성능 카운터). 이러한 서로 다른 원본을 수집, 통합하여 신뢰할 수 있는 저장소에 저장합니다.
* **분석 및 진단**. 데이터를 통합한 후에는 데이터를 분석하여 문제를 해결하고 응용 프로그램 상태에 대한 전체적인 보기를 제공할 수 있습니다.
* **시각화 및 경고**. 이 단계에서는 운영자가 문제 또는 추세를 신속하게 파악할 수 있는 방식으로 원격 분석 데이터가 제공됩니다. 대시보드 또는 전자 메일 경고를 예로 들 수 있습니다.  

모니터링은 오류 감지와 다릅니다. 예를 들어 응용 프로그램이 임시 오류 및 다시 시도를 감지했지만, 결과적으로 가동 중지 없이 넘어갈 수 있습니다. 하지만 그렇더라도 오류 비율을 모니터링하여 응용 프로그램의 전체적인 상태를 확인할 수 있도록 응용 프로그램에서 다시 시도 작업을 로깅해야 합니다. 

응용 프로그램 로그는 진단 데이터의 중요한 소스입니다. 응용 프로그램 로깅에 대한 모범 사례는 다음과 같습니다.

* 프로덕션 환경에 로그인합니다. 그렇지 않으면 데이터가 가장 필요할 때 데이터를 얻을 수 없습니다.
* 서비스 경계에서 이벤트를 로깅합니다. 서비스 경계 너머로 흐르는 상관 관계 ID를 포함합니다. 한 트랜잭션이 여러 서비스를 통과하는데 그 중 하나가 실패하면 상관 관계 ID를 통해 트랜잭션 실패 이유를 찾아낼 수 있습니다.
* 구조적 로깅이라고도 하는 의미 체계 로깅을 사용합니다. 구조화되지 않은 로그는 클라우드 규모에서 필요한 로그 데이터의 사용 및 분석 자동화가 어렵습니다.
* 비동기 로깅을 사용합니다. 그렇지 않으면 로깅 시스템 자체에서 요청을 백업하게 하여 응용 프로그램 오류가 발생할 수 있습니다. 요청 로깅 이벤트 작성을 기다리는 동안 요청이 차단되기 때문입니다.
* 응용 프로그램 로깅은 감사와 다릅니다. 감사는 규정 또는 규제 준수를 위해 수행됩니다. 따라서 감사 레코드는 완전해야 하고, 트랜잭션을 처리하는 동안 손실이 발생하면 안 됩니다. 응용 프로그램에서 감사를 요구하는 경우 감사 레코드를 진단 로깅과 별도로 보관해야 합니다. 

모니터링 및 진단에 대한 자세한 내용은 [모니터링 및 진단 지침][monitoring-guidance]을 참조하세요.

## <a name="manual-failure-responses"></a>수동 오류 대응
이전 섹션에서는 고가용성을 위해 중요한 자동 복구 전략에 집중했습니다. 그러나 경우에 따라 수동 개입이 필요할 때도 있습니다.

* **경고**. 응용 프로그램을 모니터링하여 사전 개입이 필요할 수도 있는 경고 기호를 확인합니다. 예를 들어 SQL Database 또는 Cosmos DB가 지속적으로 응용 프로그램을 제한하는 것을 확인하면 데이터베이스 용량을 높이거나 쿼리를 최적화해야 할 수도 있습니다. 이 예제에서는 응용 프로그램이 제한 오류를 투명하게 처리할 수도 있지만 후속 조치를 취할 수 있도록 원격 분석에서 계속 경고를 보내야 합니다.  
* **수동 장애 조치(Failover)**. 일부 시스템은 자동 장애 조치(failover)가 불가능하기 때문에 수동 장애 조치(failover)가 필요합니다. 
* **운영 준비 테스트**. 응용 프로그램이 보조 지역으로 장애 조치(failover)되는 경우 주 지역으로 장애 복구(failback)하기 전에 운영 준비 테스트를 수행해야 합니다. 테스트를 통해 주 지역이 정상 상태이고 다시 트래픽을 받을 준비가 되었는지 확인해야 합니다.
* **데이터 일관성 확인**. 데이터 저장소에 오류가 발생한 후 데이터를 다시 사용할 수 있게 되었을 때, 특히 데이터가 복제된 경우 데이터 불일치가 있을 수 있습니다. 
* **백업에서 복원**. 예를 들어 한 지역의 SQL Database가 가동 중지된 경우 최신 백업을 사용하여 데이터베이스를 지역 복원할 수 있습니다.

재해 복구 계획을 문서화 및 테스트합니다. 응용 프로그램 오류가 비즈니스에 미치는 영향을 평가합니다. 프로세스를 최대한 자동화하고 수동 장애 조치(failover), 백업에서 데이터 복원 등의 수동 단계를 문서화합니다. 재해 복구 프로세스를 주기적으로 테스트하여 유효성을 검사하고 계획을 개선합니다. 

## <a name="summary"></a>요약
이 문서에서는 전체적인 관점에서 복원력을 살펴보고, 클라우드의 고유한 과제 중 일부를 강조했습니다. 그 중에는 분산, 상용 하드웨어 사용, 일시적 네트워크 오류라는 클라우드 컴퓨팅의 특성도 포함되어 있습니다.

다음은 이 문서에서 기억해야 할 핵심 내용입니다.

* 복원력이 높으면 가용성이 높고 평균 오류 복구 시간은 짧습니다. 
* 클라우드에서 높은 복원력을 얻으려면 기존 온-프레미스 솔루션과는 다른 여러 기술 집합이 필요합니다. 
* 복원력은 우연히 얻을 수 없습니다. 처음부터 디자인하고 구축해야 합니다.
* 복원력은 계획부터 코딩 및 운영까지 응용 프로그램의 모든 수명 주기와 관련되어 있습니다.
* 테스트하고 모니터링하세요!


<!-- links -->

[blue-green]: http://martinfowler.com/bliki/BlueGreenDeployment.html
[canary-release]: http://martinfowler.com/bliki/CanaryRelease.html
[circuit-breaker-pattern]: https://msdn.microsoft.com/library/dn589784.aspx
[compensating-transaction-pattern]: https://msdn.microsoft.com/library/dn589804.aspx
[containers]: https://en.wikipedia.org/wiki/Operating-system-level_virtualization
[dsc]: /azure/automation/automation-dsc-overview
[contingency-planning-guide]: http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-34r1.pdf
[fma]: failure-mode-analysis.md
[hystrix]: http://techblog.netflix.com/2012/11/hystrix.html
[jmeter]: http://jmeter.apache.org/
[load-leveling-pattern]: ../patterns/queue-based-load-leveling.md
[monitoring-guidance]: ../best-practices/monitoring.md
[ra-basic-web]: ../reference-architectures/app-service-web-app/basic-web-app.md
[ra-multi-vm]: ../reference-architectures/virtual-machines-windows/multi-vm.md
[checklist]: ../checklist/resiliency.md
[retry-pattern]: ../patterns/retry.md
[retry-service-specific guidance]: ../best-practices/retry-service-specific.md
[sla]: https://azure.microsoft.com/support/legal/sla/
[throttling-pattern]: ../patterns/throttling.md
[tm]: https://azure.microsoft.com/services/traffic-manager/
[tm-failover]: /azure/traffic-manager/traffic-manager-monitoring
[tm-sla]: https://azure.microsoft.com/support/legal/sla/traffic-manager/v1_0/
[vsts]: https://www.visualstudio.com/features/vso-cloud-load-testing-vs.aspx
