---
title: '기술 지침: Azure에서 로컬 오류 복구'
description: Azure 내에서 로컬 오류에 중점을 둔 재해 복구에 대한 계획 뿐만 아니라 복원력 있고 항상 사용 가능한 내결함성 응용 프로그램을 이해하고 설계하는 방법에 대한 문서입니다.
author: adamglick
ms.date: 08/18/2016
ms.openlocfilehash: 5fc929bd1affe3dd6616f908bae0e7d2fefb89d5
ms.sourcegitcommit: e67b751f230792bba917754d67789a20810dc76b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/06/2018
ms.locfileid: "30846837"
---
[!INCLUDE [header](../_includes/header.md)]

# <a name="azure-resiliency-technical-guidance-recovery-from-local-failures-in-azure"></a><span data-ttu-id="aef3a-103">Azure 복원력 기술 지침 - Azure의 로컬 오류로부터 복구</span><span class="sxs-lookup"><span data-stu-id="aef3a-103">Azure resiliency technical guidance: Recovery from local failures in Azure</span></span>

<span data-ttu-id="aef3a-104">응용 프로그램에 대한 다음과 같은 두 가지 주요 위협 요인이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-104">There are two primary threats to application availability:</span></span>

* <span data-ttu-id="aef3a-105">드라이브 및 서버와 같은 장치의 오류</span><span class="sxs-lookup"><span data-stu-id="aef3a-105">The failure of devices, such as drives and servers</span></span>
* <span data-ttu-id="aef3a-106">최대 부하 조건에서 계산 등 중요한 리소스 소모</span><span class="sxs-lookup"><span data-stu-id="aef3a-106">The exhaustion of critical resources, such as compute under peak load conditions</span></span>

<span data-ttu-id="aef3a-107">Azure는 리소스 관리, 유연성, 부하 분산 및 분할을 조합하여 이러한 상황에서 가용성을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-107">Azure provides a combination of resource management, elasticity, load balancing, and partitioning to enable high availability under these circumstances.</span></span> <span data-ttu-id="aef3a-108">이러한 기능 중 일부는 모든 Azure 서비스에서 자동으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-108">Some of these features are performed automatically for all Azure services.</span></span> <span data-ttu-id="aef3a-109">그러나 경우에 따라 응용 프로그램 개발자는 몇 가지 추가 작업을 수행해야만 혜택을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-109">However, in some cases, the application developer must do some additional work to benefit from them.</span></span>

## <a name="cloud-services"></a><span data-ttu-id="aef3a-110">Cloud Services</span><span class="sxs-lookup"><span data-stu-id="aef3a-110">Cloud Services</span></span>
<span data-ttu-id="aef3a-111">Azure Cloud Services는 하나 이상의 웹 또는 작업자 역할의 컬렉션으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-111">Azure Cloud Services consists of collections of one or more web or worker roles.</span></span> <span data-ttu-id="aef3a-112">하나 이상인 역할의 인스턴스를 동시에 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-112">One or more instances of a role can run concurrently.</span></span> <span data-ttu-id="aef3a-113">구성은 인스턴스 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-113">The configuration determines the number of instances.</span></span> <span data-ttu-id="aef3a-114">역할 인스턴스는 패브릭 컨트롤러라는 구성 요소를 통해 모니터링되고 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-114">Role instances are monitored and managed through a component called the fabric controller.</span></span> <span data-ttu-id="aef3a-115">패브릭 컨트롤러는 자동으로 소프트웨어와 하드웨어 오류를 감지하고 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-115">The fabric controller detects and responds to both software and hardware failures automatically.</span></span>

<span data-ttu-id="aef3a-116">모든 역할 인스턴스는 고유한 VM(가상 컴퓨터)에서 실행되고 게스트 에이전트를 통해 패브릭 컨트롤러와 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-116">Every role instance runs in its own virtual machine (VM) and communicates with its fabric controller through a guest agent.</span></span> <span data-ttu-id="aef3a-117">게스트 에이전트는 VM 사용, 상태, 로그, 리소스 사용, 예외 및 오류 상태를 포함하는 리소스 및 노드 메트릭을 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-117">The guest agent collects resource and node metrics, including VM usage, status, logs, resource usage, exceptions, and failure conditions.</span></span> <span data-ttu-id="aef3a-118">패브릭 컨트롤러는 구성 가능한 간격의 게스트 에이전트를 쿼리하고 게스트 에이전트가 응답하지 못하는 경우 VM을 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-118">The fabric controller queries the guest agent at configurable intervals, and it restarts the VM if the guest agent fails to respond.</span></span> <span data-ttu-id="aef3a-119">하드웨어 오류가 발생한 경우 연결된 패브릭 컨트롤러는 영향을 받은 모든 역할 인스턴스를 새 하드웨어 노드로 이동하고 거기서 트래픽을 라우팅하도록 네트워크를 다시 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-119">In the event of hardware failure, the associated fabric controller moves all affected role instances to a new hardware node and reconfigures the network to route traffic there.</span></span>

<span data-ttu-id="aef3a-120">이러한 기능을 제대로 활용하려면 개발자는 모든 서비스 역할이 역할 인스턴스에 상태를 저장하지 않도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-120">To benefit from these features, developers should ensure that all service roles avoid storing state on the role instances.</span></span> <span data-ttu-id="aef3a-121">대신, 모든 영구 데이터는 Azure Storage 또는 Azure SQL Database와 같은 지속성 저장소에서 액세스되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-121">Instead, all persistent data should be accessed from durable storage, such as Azure Storage or Azure SQL Database.</span></span> <span data-ttu-id="aef3a-122">이렇게 하면 역할이 요청을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-122">This allows any roles to handle requests.</span></span> <span data-ttu-id="aef3a-123">즉, 역할 인스턴스가 서비스의 임시 상태나 영구 상태에서 불일치를 만들지 않고 언제든지 중단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-123">It also means that role instances can go down at any time without creating inconsistencies in the transient or persistent state of the service.</span></span>

<span data-ttu-id="aef3a-124">역할 외부에 상태를 저장하라는 요구 사항은 여러 가지를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-124">The requirement to store state externally to the roles has several implications.</span></span> <span data-ttu-id="aef3a-125">예를 들어 가능한 경우 단일 엔터티 그룹 트랜잭션에서 Azure Storage 테이블에 대한 모든 관련된 변경 사항을 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-125">It implies, for example, that all related changes to an Azure Storage table should be changed in a single entity-group transaction, if possible.</span></span> <span data-ttu-id="aef3a-126">물론 단일 트랜잭션에서 모든 사항을 변경할 수 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-126">Of course, it isn't always possible to make all changes in a single transaction.</span></span> <span data-ttu-id="aef3a-127">서비스의 영구 상태에 대한 두 개 이상의 업데이트에 걸쳐 있는 장기 실행 작업을 중단시킬 경우 역할 인스턴스 오류가 문제를 발생시키지 않도록 특별히 주의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-127">You must take special care to ensure that role instance failures do not cause problems when they interrupt long-running operations that span two or more updates to the persistent state of the service.</span></span> <span data-ttu-id="aef3a-128">다른 역할이 이러한 작업을 다시 시도하려면 작업이 부분적으로 완료된 경우 이를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-128">If another role attempts to retry such an operation, it should anticipate and handle the case where the work was partially completed.</span></span>

<span data-ttu-id="aef3a-129">예를 들어 여러 저장소에 데이터를 분할하는 서비스를 사용하도록 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-129">For example, consider a service that partitions data across multiple stores.</span></span> <span data-ttu-id="aef3a-130">작업자 역할이 분할된 데이터베이스를 재배치하는 동안 중단되더라도 분할된 데이터베이스의 재배치는 종료되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-130">If a worker role goes down while it's relocating a shard, the relocation of the shard might not finish.</span></span> <span data-ttu-id="aef3a-131">또는 재배치가 다른 작업자 역할에 의해 처음부터 반복될 수 있습니다. 이는 잠재적으로 분리된 데이터 또는 데이터 손상을 초래합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-131">Or the relocation might be repeated from its inception by a different worker role, potentially causing orphaned data or data corruption.</span></span> <span data-ttu-id="aef3a-132">문제를 방지하려면 장기 실행 작업은 다음 중 하나 또는 모두여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-132">To prevent problems, long-running operations must be one or both of the following:</span></span>

* <span data-ttu-id="aef3a-133">*Idempotent*: 부작용 없이 반복 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-133">*Idempotent*: Repeatable without side effects.</span></span> <span data-ttu-id="aef3a-134">Idempotent이려면 장기 실행 작업은 실행하는 동안 중단되는 경우더라도 실행되는 횟수에 관계 없이 동일한 효과를 가져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-134">To be idempotent, a long-running operation should have the same effect no matter how many times it's executed, even when it's interrupted during execution.</span></span>
* <span data-ttu-id="aef3a-135">*증분 방식으로 다시 시작 가능*: 가장 최근의 오류 지점에서 계속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-135">*Incrementally restartable*: Able to continue from the most recent point of failure.</span></span> <span data-ttu-id="aef3a-136">증분 방식으로 다시 시작 가능하려면 장기 실행 작업은 보다 작은 원자성 작업의 시퀀스로 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-136">To be incrementally restartable, a long-running operation should consist of a sequence of smaller atomic operations.</span></span> <span data-ttu-id="aef3a-137">또한 각 후속 호출이 이전 버전에서 중지된 위치를 선택하도록 해당 진행 상태를 지속성 저장소에 기록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-137">It should also record its progress in durable storage, so that each subsequent invocation picks up where its predecessor stopped.</span></span>

<span data-ttu-id="aef3a-138">마지막으로 모든 장기 실행 작업은 성공할 때까지 반복적으로 호출되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-138">Finally, all long-running operations should be invoked repeatedly until they succeed.</span></span> <span data-ttu-id="aef3a-139">예를 들어 프로비전 작업은 Azure 큐에 배치되고 성공한 경우에 작업자 역할에 의해 큐에서 제거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-139">For example, a provisioning operation might be placed in an Azure queue, and then removed from the queue by a worker role only when it succeeds.</span></span> <span data-ttu-id="aef3a-140">가비지 수집은 중단된 작업이 만든 데이터를 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-140">Garbage collection might be necessary to clean up data that interrupted operations create.</span></span>

### <a name="elasticity"></a><span data-ttu-id="aef3a-141">탄력성</span><span class="sxs-lookup"><span data-stu-id="aef3a-141">Elasticity</span></span>
<span data-ttu-id="aef3a-142">각 역할에 실행되는 인스턴스의 초기 수는 각 역할의 구성에서 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-142">The initial number of instances running for each role is determined in each role’s configuration.</span></span> <span data-ttu-id="aef3a-143">관리자는 역할 각각을 처음에 구성하여 예상된 부하에 따라 두 개 이상의 인스턴스를 사용하여 실행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-143">Administrators should initially configure each role to run with two or more instances based on expected load.</span></span> <span data-ttu-id="aef3a-144">그러나 역할 인스턴스를 사용량 패턴 변경으로 쉽게 확장하거나 축소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-144">But you can easily scale role instances up or down as usage patterns change.</span></span> <span data-ttu-id="aef3a-145">Azure 포털에서 수동으로 수행할 수 있고 Windows PowerShell, Service Management API 또는 타사 도구를 사용하여 프로세스를 자동화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-145">You can do this manually in the Azure portal, or you can automate the process by using Windows PowerShell, the Service Management API, or third-party tools.</span></span> <span data-ttu-id="aef3a-146">자세한 내용은 [응용 프로그램 크기를 자동 조정하는 방법](/azure/cloud-services/cloud-services-how-to-scale/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-146">For more information, see [How to autoscale an application](/azure/cloud-services/cloud-services-how-to-scale/).</span></span>

### <a name="partitioning"></a><span data-ttu-id="aef3a-147">분할</span><span class="sxs-lookup"><span data-stu-id="aef3a-147">Partitioning</span></span>
<span data-ttu-id="aef3a-148">Azure 패브릭 컨트롤러는 두 가지 유형의 파티션을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-148">The Azure fabric controller uses two types of partitions:</span></span>

* <span data-ttu-id="aef3a-149">그룹에서 서비스의 역할 인스턴스를 업그레이드하는 데 *업데이트 도메인* 을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-149">An *update domain* is used to upgrade a service’s role instances in groups.</span></span> <span data-ttu-id="aef3a-150">Azure는 여러 개의 업데이트 도메인에 서비스 인스턴스를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-150">Azure deploys service instances into multiple update domains.</span></span> <span data-ttu-id="aef3a-151">전체 업데이트의 경우 패브릭 컨트롤러는 하나의 업데이트 도메인에 있는 모든 인스턴스를 가져와서 업데이트한 후에 다음 업데이트 도메인으로 이동하기 전에 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-151">For an in-place update, the fabric controller brings down all the instances in one update domain, updates them, and then restarts them before moving to the next update domain.</span></span> <span data-ttu-id="aef3a-152">이 방법은 업데이트 과정에서 전체 서비스를 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-152">This approach prevents the entire service from being unavailable during the update process.</span></span>
* <span data-ttu-id="aef3a-153">*장애 도메인* 은 하드웨어 또는 네트워크 오류의 잠재적인 지점을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-153">A *fault domain* defines potential points of hardware or network failure.</span></span> <span data-ttu-id="aef3a-154">둘 이상의 인스턴스가 있는 역할의 경우 패브릭 컨트롤러는 분리된 하드웨어 오류가 서비스를 중단하지 않도록 방지하기 위해 인스턴스가 여러 장애 도메인에 걸쳐 분산되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-154">For any role that has more than one instance, the fabric controller ensures that the instances are distributed across multiple fault domains, to prevent isolated hardware failures from disrupting service.</span></span> <span data-ttu-id="aef3a-155">장애 도메인은 서버와 클러스터 오류에 대한 노출을 모두 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-155">Fault domains govern all exposure to server and cluster failures.</span></span>

<span data-ttu-id="aef3a-156">둘 이상의 웹 역할 인스턴스를 여러 장애 도메인 및 업그레이드 도메인에 배포하는 경우 Microsoft는 [Azure SLA(서비스 수준 계약)](https://azure.microsoft.com/support/legal/sla/) 는 적어도 99.95% 이상 외부와 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-156">The [Azure service-level agreement (SLA)](https://azure.microsoft.com/support/legal/sla/) guarantees that when two or more web role instances are deployed to different fault and upgrade domains, they'll have external connectivity at least 99.95 percent of the time.</span></span> <span data-ttu-id="aef3a-157">업데이트 도메인과 달리 장애 도메인의 수를 제어할 방법이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-157">Unlike update domains, there's no way to control the number of fault domains.</span></span> <span data-ttu-id="aef3a-158">Azure는 자동으로 장애 도메인을 할당하고 이들 간에 역할 인스턴스를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-158">Azure automatically allocates fault domains and distributes role instances across them.</span></span> <span data-ttu-id="aef3a-159">적어도 두 개의 인스턴스로 역할이 SLA를 충족하도록 하려면 적어도 모든 역할에서 처음 두 개의 인스턴스를 다른 장애 도메인 및 업그레이드 도메인에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-159">At least the first two instances of every role are placed in different fault and upgrade domains to ensure that any role with at least two instances will satisfy the SLA.</span></span> <span data-ttu-id="aef3a-160">이 내용은 다음 다이어그램에서 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-160">This is represented in the following diagram.</span></span>

![장애 도메인 격리의 단순화된 보기](./images/technical-guidance-recovery-local-failures/partitioning-1.png)

### <a name="load-balancing"></a><span data-ttu-id="aef3a-162">부하 분산</span><span class="sxs-lookup"><span data-stu-id="aef3a-162">Load balancing</span></span>
<span data-ttu-id="aef3a-163">웹 역할에 대한 인바운드 트래픽은 모두 상태 비저장 부하 분산 장치를 통해 전달되며 역할 인스턴스에 클라이언트 요청을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-163">All inbound traffic to a web role passes through a stateless load balancer, which distributes client requests among the role instances.</span></span> <span data-ttu-id="aef3a-164">개별 역할 인스턴스에는 공용 IP 주소가 없으며 인터넷에서 직접 주소를 지정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-164">Individual role instances do not have public IP addresses, and they are not directly addressable from the Internet.</span></span> <span data-ttu-id="aef3a-165">웹 역할은 상태 비저장이므로 클라이언트 요청을 어떠한 역할 인스턴스로도 라우팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-165">Web roles are stateless so that any client request can be routed to any role instance.</span></span> <span data-ttu-id="aef3a-166">[StatusCheck](https://msdn.microsoft.com/library/microsoft.windowsazure.serviceruntime.roleenvironment.statuscheck.aspx) 이벤트는 15초마다 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-166">A [StatusCheck](https://msdn.microsoft.com/library/microsoft.windowsazure.serviceruntime.roleenvironment.statuscheck.aspx) event is raised every 15 seconds.</span></span> <span data-ttu-id="aef3a-167">역할이 트래픽을 받을 준비가 되거나 사용 중이어서 부하 분산 장치 순환에서 제거되어야 함을 나타내는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-167">You can use this to indicate whether the role is ready to receive traffic, or whether it's busy and should be taken out of the load-balancer rotation.</span></span>

## <a name="virtual-machines"></a><span data-ttu-id="aef3a-168">Virtual Machines</span><span class="sxs-lookup"><span data-stu-id="aef3a-168">Virtual Machines</span></span>
<span data-ttu-id="aef3a-169">Azure Virtual Machines는 고가용성과 관련된 몇 가지 측면에서 PaaS(platform as a service) 계산 역할과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-169">Azure Virtual Machines differs from platform as a service (PaaS) compute roles in several respects in relation to high availability.</span></span> <span data-ttu-id="aef3a-170">일부 인스턴스에서 고가용성을 보장하기 위해 추가적인 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-170">In some instances, you must do additional work to ensure high availability.</span></span>

### <a name="disk-durability"></a><span data-ttu-id="aef3a-171">디스크 내구성</span><span class="sxs-lookup"><span data-stu-id="aef3a-171">Disk durability</span></span>
<span data-ttu-id="aef3a-172">PaaS 역할 인스턴스와 달리 가상 머신이 재배치되는 경우 가상 머신 드라이브에 저장된 데이터는 영구적입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-172">Unlike PaaS role instances, data stored on virtual machine drives is persistent even when the virtual machine is relocated.</span></span> <span data-ttu-id="aef3a-173">Azure 가상 머신은 Azure Storage에서 Blob으로 존재하는 VM 디스크를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-173">Azure virtual machines use VM disks that exist as blobs in Azure Storage.</span></span> <span data-ttu-id="aef3a-174">또한 Azure Storage의 가용성 특성 때문에 가상 머신의 드라이브에 저장된 데이터를 항상 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-174">Because of the availability characteristics of Azure Storage, the data stored on a virtual machine’s drives is also highly available.</span></span>

<span data-ttu-id="aef3a-175">D 드라이브(Windows VM)는 이 규칙의 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-175">Note that drive D (in Windows VMs) is the exception to this rule.</span></span> <span data-ttu-id="aef3a-176">D 드라이브는 VM을 호스팅하는 랙 서버에 실제 물리적 저장소이며 VM을 재활용하는 경우 해당 데이터가 손실됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-176">Drive D is actually physical storage on the rack server that hosts the VM, and its data will be lost if the VM is recycled.</span></span> <span data-ttu-id="aef3a-177">D 드라이브는 임시 저장소로만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-177">Drive D is intended for temporary storage only.</span></span> <span data-ttu-id="aef3a-178">Linux에서 Azure는 "일반적으로"(항상 그렇지는 않음) 로컬 임시 디스크를 /dev/sdb 블록 장치로 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-178">In Linux, Azure “usually” (but not always) exposes the local temporary disk as /dev/sdb block device.</span></span> <span data-ttu-id="aef3a-179">Azure Linux 에이전트에 의해 /mnt/resource 또는 /mnt 탑재 지점으로 탑재되는 경우가 많습니다(/etc/waagent.conf를 통해 구성 가능).</span><span class="sxs-lookup"><span data-stu-id="aef3a-179">It is often mounted by the Azure Linux Agent as /mnt/resource or /mnt mount points (configurable via /etc/waagent.conf).</span></span>

### <a name="partitioning"></a><span data-ttu-id="aef3a-180">분할</span><span class="sxs-lookup"><span data-stu-id="aef3a-180">Partitioning</span></span>
<span data-ttu-id="aef3a-181">Azure는 PaaS 응용 프로그램(웹 역할 및 작업자 역할)의 계층을 기본적으로 이해하므로 장애 도메인 및 업데이트 도메인에 걸쳐 제대로 배포될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-181">Azure natively understands the tiers in a PaaS application (web role and worker role) and thus can properly distribute them across fault and update domains.</span></span> <span data-ttu-id="aef3a-182">반면에 IaaS(infrastructure as a service) 응용 프로그램의 계층은 가용성 집합을 통해 수동으로 정의되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-182">In contrast, the tiers in an infrastructure as a service (IaaS) application must be manually defined through availability sets.</span></span> <span data-ttu-id="aef3a-183">가용성 집합은 IaaS에서 SLA에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-183">Availability sets are required for an SLA under IaaS.</span></span>

![Azure 가상 머신에 대한 가용성 집합](./images/technical-guidance-recovery-local-failures/partitioning-2.png)

<span data-ttu-id="aef3a-185">위의 다이어그램에서 웹앱 계층으로 작동하는 IIS(인터넷 정보 서비스) 계층 및 데이터 계층으로 작동하는 SQL 계층은 서로 다른 가용성 집합에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-185">In the preceding diagram, the Internet Information Services (IIS) tier (which works as a web app tier) and the SQL tier (which works as a data tier) are assigned to different availability sets.</span></span> <span data-ttu-id="aef3a-186">이렇게 하면 각 계층의 모든 인스턴스가 장애 도메인에 가상 머신을 분산하여 하드웨어 중복성을 가질 수 있고 업데이트하는 동안 전체 계층의 작동이 중단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-186">This ensures that all instances of each tier have hardware redundancy by distributing virtual machines across fault domains, and that entire tiers are not taken down during an update.</span></span>

### <a name="load-balancing"></a><span data-ttu-id="aef3a-187">부하 분산</span><span class="sxs-lookup"><span data-stu-id="aef3a-187">Load balancing</span></span>
<span data-ttu-id="aef3a-188">VM에 트래픽을 분산해야 하는 경우 응용 프로그램에서 VM을 그룹화하고 특정 TCP 또는 UDP 끝점에서 부하를 분산해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-188">If the VMs should have traffic distributed across them, you must group the VMs in an application and load balance across a specific TCP or UDP endpoint.</span></span> <span data-ttu-id="aef3a-189">자세한 내용은 [가상 머신 부하 분산](/azure/virtual-machines/virtual-machines-linux-load-balance/?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)(영문)을 참조하십시오.</span><span class="sxs-lookup"><span data-stu-id="aef3a-189">For more information, see [Load balancing virtual machines](/azure/virtual-machines/virtual-machines-linux-load-balance/?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span> <span data-ttu-id="aef3a-190">VM이 다른 원본(예: 큐 메커니즘)에서 입력을 수신하는 경우 부하 분산 장치가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-190">If the VMs receive input from another source (for example, a queuing mechanism), a load balancer is not required.</span></span> <span data-ttu-id="aef3a-191">부하 분산 장치는 기본적인 상태 검사를 사용하여 트래픽이 노드로 전송되어야 하는지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-191">The load balancer uses a basic health check to determine whether traffic should be sent to the node.</span></span> <span data-ttu-id="aef3a-192">또한 고유한 프로브를 만들어 VM 트래픽을 수신해야 하는지를 결정하는 응용 프로그램 관련 상태 메트릭을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-192">It's also possible to create your own probes to implement application-specific health metrics that determine whether the VM should receive traffic.</span></span>

## <a name="storage"></a><span data-ttu-id="aef3a-193">Storage</span><span class="sxs-lookup"><span data-stu-id="aef3a-193">Storage</span></span>
<span data-ttu-id="aef3a-194">Azure Storage는 Azure에 대한 지속 가능한 기본 데이터 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-194">Azure Storage is the baseline durable data service for Azure.</span></span> <span data-ttu-id="aef3a-195">Blob, 테이블, 큐 및 VM 디스크 저장소를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-195">It provides blob, table, queue, and VM disk storage.</span></span> <span data-ttu-id="aef3a-196">복제 및 리소스 관리의 조합을 사용하여 단일 데이터 센터 내에서 고가용성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-196">It uses a combination of replication and resource management to provide high availability within a single datacenter.</span></span> <span data-ttu-id="aef3a-197">Azure Storage 가용성 SLA는 최소한 99.9%의 시간을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-197">The Azure Storage availability SLA guarantees that at least 99.9 percent of the time:</span></span>

* <span data-ttu-id="aef3a-198">데이터를 추가, 업데이트, 읽기 및 삭제할 올바른 형식이 지정된 요청이 성공적이고 올바르게 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-198">Correctly formatted requests to add, update, read, and delete data will be successfully and correctly processed.</span></span>
* <span data-ttu-id="aef3a-199">Storage 계정은 인터넷 게이트웨이에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-199">Storage accounts will have connectivity to the Internet gateway.</span></span>

### <a name="replication"></a><span data-ttu-id="aef3a-200">복제</span><span class="sxs-lookup"><span data-stu-id="aef3a-200">Replication</span></span>
<span data-ttu-id="aef3a-201">Azure Storage는 지역 내에서 완전히 독립된 물리적 저장소 하위 시스템에서 여러 드라이브에 있는 모든 데이터의 여러 복사본을 유지 관리하여 데이터 내구성을 촉진합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-201">Azure Storage facilitates data durability by maintaining multiple copies of all data on different drives across fully independent physical storage subsystems within the region.</span></span> <span data-ttu-id="aef3a-202">데이터를 동기적으로 복제하고 쓰기를 승인하기 전에 모든 복사본을 커밋합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-202">Data is replicated synchronously, and all copies are committed before the write is acknowledged.</span></span> <span data-ttu-id="aef3a-203">Azure Storage는 강력한 일관성을 유지하여 읽기가 가장 최근의 쓰기를 반영하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-203">Azure Storage is strongly consistent, meaning that reads are guaranteed to reflect the most recent writes.</span></span> <span data-ttu-id="aef3a-204">또한 데이터의 복사본을 지속적으로 스캔하여 저장된 데이터의 무결성에 위협이 되지만 흔히 간과하는 비트 손상을 탐색하고 복구합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-204">In addition, copies of data are continually scanned to detect and repair bit rot, an often overlooked threat to the integrity of stored data.</span></span>

<span data-ttu-id="aef3a-205">서비스는 Azure Storage를 사용하여 복제를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-205">Services benefit from replication just by using Azure Storage.</span></span> <span data-ttu-id="aef3a-206">서비스 개발자는 로컬 오류로부터 복구하기 위해 추가 작업을 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-206">The service developer doesn't need to do additional work to recover from a local failure.</span></span>

### <a name="resource-management"></a><span data-ttu-id="aef3a-207">리소스 관리</span><span class="sxs-lookup"><span data-stu-id="aef3a-207">Resource management</span></span>
<span data-ttu-id="aef3a-208">2014년 5월 이후에 만들어진 Storage 계정은 최대 500TB까지 가능합니다(이전 최대 크기는 200TB).</span><span class="sxs-lookup"><span data-stu-id="aef3a-208">Storage accounts created after May 2014, can grow to up to 500 TB (the previous maximum was 200 TB).</span></span> <span data-ttu-id="aef3a-209">추가 공간이 필요한 경우 응용 프로그램이 여러 저장소 계정을 사용하도록 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-209">If additional space is required, applications must be designed to use multiple storage accounts.</span></span>

### <a name="virtual-machine-disks"></a><span data-ttu-id="aef3a-210">가상 머신 디스크</span><span class="sxs-lookup"><span data-stu-id="aef3a-210">Virtual machine disks</span></span>
<span data-ttu-id="aef3a-211">가상 머신의 VM 디스크는 Azure Storage에서 페이지 Blob으로 저장되고 Blob Storage와 동일한 내구성 및 확장성 속성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-211">A virtual machine’s disk is stored as a page blob in Azure Storage, giving it all the same durability and scalability properties as Blob storage.</span></span> <span data-ttu-id="aef3a-212">이 설계를 통해 VM을 실행하는 서버가 실패하고 다른 서버에서 VM이 다시 시작해야 하더라도 가상 머신의 디스크에 있는 데이터를 영구적으로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-212">This design makes the data on a virtual machine’s disk persistent, even if the server running the VM fails and the VM must be restarted on another server.</span></span>

## <a name="database"></a><span data-ttu-id="aef3a-213">데이터베이스</span><span class="sxs-lookup"><span data-stu-id="aef3a-213">Database</span></span>
### <a name="sql-database"></a><span data-ttu-id="aef3a-214">SQL Database</span><span class="sxs-lookup"><span data-stu-id="aef3a-214">SQL Database</span></span>
<span data-ttu-id="aef3a-215">Azure SQL Database는 DaaS(database as a service)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-215">Azure SQL Database provides database as a service.</span></span> <span data-ttu-id="aef3a-216">응용 프로그램을을 신속하게 프로비전하고 데이터를 삽입하며 관계형 데이터베이스를 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-216">It allows applications to quickly provision, insert data into, and query relational databases.</span></span> <span data-ttu-id="aef3a-217">친숙한 여러 SQL Server 기능을 제공하는 동시에 하드웨어, 구성, 패치 및 복구의 부담을 줄였습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-217">It provides many of the familiar SQL Server features and functionality, while abstracting the burden of hardware, configuration, patching, and resiliency.</span></span>

> [!NOTE]
> <span data-ttu-id="aef3a-218">Azure SQL Database는 SQL Server와 일대일 기능 패리티를 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-218">Azure SQL Database does not provide one-to-one feature parity with SQL Server.</span></span> <span data-ttu-id="aef3a-219">클라우드 응용 프로그램에 고유하게 맞춘 일련의 요구 사항을 만족하도록 계획되었습니다(유지 관리 비용을 절감하는 탄력적인 확장, DaaS(Database-as-a-Service)).</span><span class="sxs-lookup"><span data-stu-id="aef3a-219">It's intended to fulfill a different set of requirements--one that's uniquely suited to cloud applications (elastic scale, database as a service to reduce maintenance costs, and so on).</span></span> <span data-ttu-id="aef3a-220">자세한 내용은 [클라우드 SQL Server 옵션 선택: Azure SQL(PaaS) 데이터베이스 또는 Azure VM(IaaS)의 SQL Server](/azure/sql-database/sql-database-paas-vs-sql-server-iaas/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-220">For more information, see [Choose a cloud SQL Server option: Azure SQL (PaaS) Database or SQL Server on Azure VMs (IaaS)](/azure/sql-database/sql-database-paas-vs-sql-server-iaas/).</span></span>
> 
> 

#### <a name="replication"></a><span data-ttu-id="aef3a-221">복제</span><span class="sxs-lookup"><span data-stu-id="aef3a-221">Replication</span></span>
<span data-ttu-id="aef3a-222">Azure SQL Database는 노드 수준 오류에 대한 기본 제공 탄력성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-222">Azure SQL Database provides built-in resiliency to node-level failure.</span></span> <span data-ttu-id="aef3a-223">데이터베이스에 대한 모든 쓰기는 쿼럼 커밋 기술을 통해 두 개 이상의 배경 노드에 자동으로 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-223">All writes into a database are automatically replicated to two or more background nodes through a quorum commit technique.</span></span> <span data-ttu-id="aef3a-224">(트랜잭션이 성공하고 반환되려먼 먼저 기본 데이터베이스와 하나 이상의 보조 복제본에서 트랜잭션 로그에 작업이 기록되었음을 확인해야 합니다.) 노드 오류가 발생할 경우 데이터베이스는 자동으로 보조 복제본 중 하나에 장애 조치합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-224">(The primary and at least one secondary must confirm that the activity is written to the transaction log before the transaction is deemed successful and returns.) In the case of node failure, the database automatically fails over to one of the secondary replicas.</span></span> <span data-ttu-id="aef3a-225">이로 인해 클라이언트 응용 프로그램에 대한 임시 연결 중단이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-225">This causes a transient connection interruption for client applications.</span></span> <span data-ttu-id="aef3a-226">이러한 이유로 Azure SQL Database 클라이언트는 모두 어떤 형태의 임시 연결 오류 처리를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-226">For this reason, all Azure SQL Database clients must implement some form of transient connection handling.</span></span> <span data-ttu-id="aef3a-227">자세한 내용은 [서비스 관련 재시도 지침](/azure/best-practices-retry-service-specific/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-227">For more information, see [Retry service specific guidance](/azure/best-practices-retry-service-specific/).</span></span>

#### <a name="resource-management"></a><span data-ttu-id="aef3a-228">리소스 관리</span><span class="sxs-lookup"><span data-stu-id="aef3a-228">Resource management</span></span>
<span data-ttu-id="aef3a-229">각 데이터베이스를 만들 경우 최대 크기 제한으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-229">Each database, when created, is configured with an upper size limit.</span></span> <span data-ttu-id="aef3a-230">현재 사용할 수 있는 최대 크기는 1TB(크기 제한은 서비스 계층에 따라 다름)입니다. [서비스 계층 및 Azure SQL Databases의 성능 수준](/azure/sql-database/sql-database-resource-limits/#service-tiers-and-performance-levels)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-230">The currently available maximum size is 1 TB (size limits vary based on your service tier, see [service tiers and performance levels of Azure SQL Databases](/azure/sql-database/sql-database-resource-limits/#service-tiers-and-performance-levels).</span></span> <span data-ttu-id="aef3a-231">데이터베이스가 최대 크기 제한에 도달하면 추가 INSERT 또는 UPDATE 명령을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-231">When a database hits its upper size limit, it rejects additional INSERT or UPDATE commands.</span></span> <span data-ttu-id="aef3a-232">(데이터 쿼리 및 삭제는 여전히 가능합니다.)</span><span class="sxs-lookup"><span data-stu-id="aef3a-232">(Querying and deleting data is still possible.)</span></span>

<span data-ttu-id="aef3a-233">데이터베이스 내에서 Azure SQL Database는 패브릭을 사용하여 리소스를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-233">Within a database, Azure SQL Database uses a fabric to manage resources.</span></span> <span data-ttu-id="aef3a-234">그러나 패브릭 컨트롤러 대신 링 토폴로지를 사용하여 오류를 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-234">However, instead of a fabric controller, it uses a ring topology to detect failures.</span></span> <span data-ttu-id="aef3a-235">클러스터에 있는 모든 복제본에는 두 개의 인접 항목이 있으며 중단되었을 경우 감지할 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-235">Every replica in a cluster has two neighbors and is responsible for detecting when they go down.</span></span> <span data-ttu-id="aef3a-236">복제본이 중단되면 인접 항목은 재구성 에이전트를 트리거하여 다른 컴퓨터에서 다시 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-236">When a replica goes down, its neighbors trigger a reconfiguration agent to re-create it on another machine.</span></span> <span data-ttu-id="aef3a-237">논리 서버가 컴퓨터에서 너무 많은 리소스를 사용하거나 컴퓨터의 물리적 제한을 초과하지 않도록 엔진 제한을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-237">Engine throttling is provided to ensure that a logical server doesn't use too many resources on a machine or exceed the machine’s physical limits.</span></span>

### <a name="elasticity"></a><span data-ttu-id="aef3a-238">탄력성</span><span class="sxs-lookup"><span data-stu-id="aef3a-238">Elasticity</span></span>
<span data-ttu-id="aef3a-239">응용 프로그램이 제한인 1TB 데이터베이스보다 더 많은 데이터베이스가 필요한 경우 규모 확장 방식을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-239">If the application requires more than the 1 TB database limit, it must implement a scale-out approach.</span></span> <span data-ttu-id="aef3a-240">여러 SQL Database 간에 데이터를 수동으로 분할하여(분할된 데이터라고도 함) Azure SQL Database의 규모를 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-240">You scale out with Azure SQL Database by manually partitioning, also known as sharding, data across multiple SQL databases.</span></span> <span data-ttu-id="aef3a-241">이 규모 확장 방법은 눈금으로 가까운 선형 비용 증가를 달성할 기회를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-241">This scale-out approach provides the opportunity to achieve nearly linear cost growth with scale.</span></span> <span data-ttu-id="aef3a-242">데이터베이스는 최대 크기가 아닌 하루에 사용되는 실제 평균 크기에 따라 요금이 청구되기 때문에 필요에 따라 비용이 증가하면서 요청되는 탄력적인 성장이나 용량도 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-242">Elastic growth or capacity on demand can grow with incremental costs as needed because databases are billed based on the average actual size used per day, not based on maximum possible size.</span></span>

## <a name="sql-server-on-virtual-machines"></a><span data-ttu-id="aef3a-243">Virtual Machines의 SQL Server</span><span class="sxs-lookup"><span data-stu-id="aef3a-243">SQL Server on Virtual Machines</span></span>
<span data-ttu-id="aef3a-244">SQL Server(버전 2014 이상)를 Azure Virtual Machines에 설치하여 SQL Server의 기존 가용성 기능을 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-244">By installing SQL Server (version 2014 or later) on Azure Virtual Machines, you can take advantage of the traditional availability features of SQL Server.</span></span> <span data-ttu-id="aef3a-245">이러한 기능에는 AlwaysOn 가용성 그룹 및 데이터베이스 미러링이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-245">These features include AlwaysOn Availability Groups and database mirroring.</span></span> <span data-ttu-id="aef3a-246">Azure VM, 저장소 및 네트워킹은 온-프레미스, 가상화되지 않은 IT 인프라에서는 작동 특성이 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-246">Note that Azure VMs, storage, and networking have different operational characteristics than an on-premises, non-virtualized IT infrastructure.</span></span> <span data-ttu-id="aef3a-247">Azure에서 고가용성/재해 복구(HA/DR) SQL Server 솔루션을 성공적으로 구현하기 위해서는 이러한 차이점을 이해하고 그에 맞게 솔루션을 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-247">A successful implementation of a high availability/disaster recovery (HA/DR) SQL Server solution in Azure requires that you understand these differences and design your solution to accommodate them.</span></span>

### <a name="high-availability-nodes-in-an-availability-set"></a><span data-ttu-id="aef3a-248">가용성 집합의 고가용성 노드</span><span class="sxs-lookup"><span data-stu-id="aef3a-248">High-availability nodes in an availability set</span></span>
<span data-ttu-id="aef3a-249">Azure의 고가용성 솔루션을 구현하는 경우 Azure의 가용성 집합을 사용하여 고가용성 노드를 별도의 장애 도메인과 업그레이드 도메인에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-249">When you implement a high-availability solution in Azure, you can use the availability set in Azure to place the high-availability nodes into separate fault domains and upgrade domains.</span></span> <span data-ttu-id="aef3a-250">분명히 하자면 가용성 집합은 Azure 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-250">To be clear, the availability set is an Azure concept.</span></span> <span data-ttu-id="aef3a-251">AlwaysOn 가용성 그룹, 미러링 또는 다른 기능을 사용하는 것과 상관 없이 데이터베이스가 실제로 항상 사용 가능한지 확인하기 위해 따라야 하는 모범 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-251">It's a best practice that you should follow to make sure that your databases are indeed highly available, whether you're using AlwaysOn Availability Groups, database mirroring, or something else.</span></span> <span data-ttu-id="aef3a-252">이 모범 사례를 따르지 않으면 시스템을 항상 사용할 수 있다고 잘못 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-252">If you don't follow this best practice, you might be under the false assumption that your system is highly available.</span></span> <span data-ttu-id="aef3a-253">하지만 Azure 지역에서 동일한 장애 도메인에 배치되었기 때문에 실제로 노드가 모두 동시에 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-253">But in reality, your nodes can all fail simultaneously because they happen to be placed in the same fault domain in the Azure region.</span></span>

<span data-ttu-id="aef3a-254">이 권장 사항은 로그 전달처럼 적용될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-254">This recommendation is not as applicable with log shipping.</span></span> <span data-ttu-id="aef3a-255">따라서 재해 복구 기능으로 서버가 별도 Azure 지역에서 실행되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-255">As a disaster recovery feature, you should ensure that the servers are running in separate Azure regions.</span></span> <span data-ttu-id="aef3a-256">기본적으로 이러한 지역은 별도의 장애 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-256">By definition, these regions are separate fault domains.</span></span>

<span data-ttu-id="aef3a-257">클래식 포털을 통해 배포되는 Azure Cloud Services가 동일한 가용성 집합에 포함되려면 동일한 클라우드 서비스에 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-257">For Azure Cloud Services VMs deployed through the classic portal to be in the same availability set, you must deploy them in the same Cloud Service.</span></span> <span data-ttu-id="aef3a-258">Azure Resource Manager(현재 포털)을 통해 배포된 VM에는 이러한 제한이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-258">VMs deployed through Azure Resource Manager (the current portal) do not have this limitation.</span></span> <span data-ttu-id="aef3a-259">Azure 클라우드 서비스의 클래식 포털 배포 VM의 경우 같은 클라우드 서비스에 있는 노드만 같은 가용성 집합에 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-259">For classic portal deployed VMs in Azure Cloud Service, only nodes in the same Cloud Service can participate in the same availability set.</span></span> <span data-ttu-id="aef3a-260">또한 Cloud Services VM은 서비스 복구 후에 해당 IP를 유지하는지 확인하기 위해 동일한 가상 네트워크에 위치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-260">In addition, the Cloud Services VMs should be in the same virtual network to ensure that they maintain their IPs even after service healing.</span></span> <span data-ttu-id="aef3a-261">그러면 DNS 업데이트 중단을 피할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-261">This avoids DNS update disruptions.</span></span>

### <a name="azure-only-high-availability-solutions"></a><span data-ttu-id="aef3a-262">Azure 전용: 고가용성 솔루션</span><span class="sxs-lookup"><span data-stu-id="aef3a-262">Azure-only: High-availability solutions</span></span>
<span data-ttu-id="aef3a-263">AlwaysOn 가용성 그룹 또는 데이터베이스 미러링을 사용하여 Azure에서 SQL Server 데이터베이스를 위한 고가용성 솔루션을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-263">You can have a high-availability solution for your SQL Server databases in Azure by using AlwaysOn Availability Groups or database mirroring.</span></span>

<span data-ttu-id="aef3a-264">다음 다이어그램에서는 Azure Virtual Machines에서 실행되는 AlwaysOn 가용성 그룹의 아키텍처를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-264">The following diagram demonstrates the architecture of AlwaysOn Availability Groups running on Azure Virtual Machines.</span></span> <span data-ttu-id="aef3a-265">이 다이어그램은 [Azure Virtual Machines에서 SQL Server에 대한 고가용성 및 재해 복구](/azure/virtual-machines/windows/sql/virtual-machines-windows-sql-high-availability-dr/)라는 제목의 심층 문서에서 가져왔습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-265">This diagram was taken from the in-depth article on this subject, [High availability and disaster recovery for SQL Server on Azure Virtual Machines](/azure/virtual-machines/windows/sql/virtual-machines-windows-sql-high-availability-dr/).</span></span>

![Microsoft Azure의 AlwaysOn 가용성 그룹](./images/technical-guidance-recovery-local-failures/high_availability_solutions-1.png)

<span data-ttu-id="aef3a-267">Azure 포털에서 AlwaysOn 템플릿을 사용하여 Azure VM에 AlwaysOn 가용성 그룹 배포 종단 간을 자동으로 프로비전할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-267">You can also automatically provision an AlwaysOn Availability Groups deployment end-to-end on Azure VMs by using the AlwaysOn template in the Azure portal.</span></span> <span data-ttu-id="aef3a-268">자세한 내용은 [Microsoft Azure Portal 갤러리의 SQL Server AlwaysOn 제품](https://blogs.technet.microsoft.com/dataplatforminsider/2014/08/25/sql-server-alwayson-offering-in-microsoft-azure-portal-gallery/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-268">For more information, see [SQL Server AlwaysOn Offering in Microsoft Azure Portal Gallery](https://blogs.technet.microsoft.com/dataplatforminsider/2014/08/25/sql-server-alwayson-offering-in-microsoft-azure-portal-gallery/).</span></span>

<span data-ttu-id="aef3a-269">다음 다이어그램은 Azure Virtual Machines에서 데이터베이스 미러링의 사용법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-269">The following diagram demonstrates the use of database mirroring on Azure Virtual Machines.</span></span> <span data-ttu-id="aef3a-270">[Azure Virtual Machines에서 SQL Server에 대한 고가용성 및 재해 복구](/azure/virtual-machines/windows/sql/virtual-machines-windows-sql-high-availability-dr/)심층 항목에서 가져왔습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-270">It was also taken from the in-depth topic [High availability and disaster recovery for SQL Server on Azure Virtual Machines](/azure/virtual-machines/windows/sql/virtual-machines-windows-sql-high-availability-dr/).</span></span>

![Microsoft Azure의 데이터베이스 미러링](./images/technical-guidance-recovery-local-failures/high_availability_solutions-2.png)

> [!NOTE]
> <span data-ttu-id="aef3a-272">두 아키텍처는 모두 도메인 컨트롤러가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-272">Both architectures require a domain controller.</span></span> <span data-ttu-id="aef3a-273">그러나 데이터베이스 미러링으로 서버 인증서를 사용하여 도메인 컨트롤러에 대한 필요성을 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-273">However, with database mirroring, it's possible to use server certificates to eliminate the need for a domain controller.</span></span>
> 
> 

## <a name="other-azure-platform-services"></a><span data-ttu-id="aef3a-274">다른 Azure 플랫폼 서비스</span><span class="sxs-lookup"><span data-stu-id="aef3a-274">Other Azure platform services</span></span>
<span data-ttu-id="aef3a-275">Azure를 기반으로 하는 응용 프로그램은 플랫폼 기능을 활용하여 로컬 오류로부터 복구합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-275">Applications that are built on Azure benefit from platform capabilities to recover from local failures.</span></span> <span data-ttu-id="aef3a-276">경우에 따라 특정 시나리오에 대한 가용성을 높이기 위해 특정 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-276">In some cases, you can take specific actions to increase availability for your specific scenario.</span></span>

### <a name="service-bus"></a><span data-ttu-id="aef3a-277">Service Bus</span><span class="sxs-lookup"><span data-stu-id="aef3a-277">Service Bus</span></span>
<span data-ttu-id="aef3a-278">Azure Service Bus의 일시적 중단을 줄이려면 내구성이 있는 클라이언트 쪽 큐를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-278">To mitigate against a temporary outage of Azure Service Bus, consider creating a durable client-side queue.</span></span> <span data-ttu-id="aef3a-279">일시적으로 대체 로컬 저장소 메커니즘을 사용하여 Service Bus 큐에 추가할 수 없는 메시지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-279">This temporarily uses an alternate, local storage mechanism to store messages that cannot be added to the Service Bus queue.</span></span> <span data-ttu-id="aef3a-280">응용 프로그램은 서비스가 복원된 후에 일시적으로 저장된 메시지를 처리하는 방법을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-280">The application can decide how to handle the temporarily stored messages after the service is restored.</span></span> <span data-ttu-id="aef3a-281">자세한 내용은 [Service Bus 조정된 메시징을 사용한 성능 향상의 모범 사례](/azure/service-bus-messaging/service-bus-performance-improvements/) 및 [Service Bus(재해 복구)](recovery-loss-azure-region.md#other-azure-platform-services)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-281">For more information, see [Best practices for performance improvements using Service Bus brokered messaging](/azure/service-bus-messaging/service-bus-performance-improvements/) and [Service Bus (disaster recovery)](recovery-loss-azure-region.md#other-azure-platform-services).</span></span>

### <a name="hdinsight"></a><span data-ttu-id="aef3a-282">HDInsight</span><span class="sxs-lookup"><span data-stu-id="aef3a-282">HDInsight</span></span>
<span data-ttu-id="aef3a-283">Azure HDInsight와 연결된 데이터는 기본적으로 Azure Blob 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-283">The data that's associated with Azure HDInsight is stored by default in Azure Blob storage.</span></span> <span data-ttu-id="aef3a-284">Azure Storage는 Blob Storage에 고가용성 및 내구성 속성을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-284">Azure Storage specifies high-availability and durability properties for Blob storage.</span></span> <span data-ttu-id="aef3a-285">Hadoop MapReduce 작업과 연결된 다중 노드는 HDInsight에서 필요할 경우 프로비전되는 일시적인 HDFS(Hadoop 분산 파일 시스템)에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-285">The multiple-node processing that's associated with Hadoop MapReduce jobs occurs on a transient Hadoop Distributed File System (HDFS) that is provisioned when HDInsight needs it.</span></span> <span data-ttu-id="aef3a-286">또한 MapReduce 작업의 결과가 기본적으로 Azure Blob 저장소에 저장되므로 처리된 데이터는 Hadoop 클러스터의 프로비전을 해제한 후에 내구성 있고 항상 사용 가능한 상태로 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-286">Results from a MapReduce job are also stored by default in Azure Blob storage, so that the processed data is durable and remains highly available after the Hadoop cluster is deprovisioned.</span></span> <span data-ttu-id="aef3a-287">자세한 내용은 [HDInsight(재해 복구)](recovery-loss-azure-region.md#other-azure-platform-services)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aef3a-287">For more information, see [HDInsight (disaster recovery)](recovery-loss-azure-region.md#other-azure-platform-services).</span></span>

## <a name="checklists-for-local-failures"></a><span data-ttu-id="aef3a-288">로컬 오류의 검사 목록</span><span class="sxs-lookup"><span data-stu-id="aef3a-288">Checklists for local failures</span></span>
### <a name="cloud-services"></a><span data-ttu-id="aef3a-289">Cloud Services</span><span class="sxs-lookup"><span data-stu-id="aef3a-289">Cloud Services</span></span>
1. <span data-ttu-id="aef3a-290">이 문서의 Cloud Services 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-290">Review the Cloud Services section of this document.</span></span>
2. <span data-ttu-id="aef3a-291">각 역할에 두 개 이상의 인스턴스를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-291">Configure at least two instances for each role.</span></span>
3. <span data-ttu-id="aef3a-292">역할 인스턴스가 아니라 내구성 저장소에서 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-292">Persist state in durable storage, not on role instances.</span></span>
4. <span data-ttu-id="aef3a-293">StatusCheck 이벤트를 올바르게 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-293">Correctly handle the StatusCheck event.</span></span>
5. <span data-ttu-id="aef3a-294">가능한 경우 트랜잭션에서 관련된 변경 내용을 래핑합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-294">Wrap related changes in transactions when possible.</span></span>
6. <span data-ttu-id="aef3a-295">작업자 역할 작업이 idempotent 또는 다시 시작 가능한지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-295">Verify that worker role tasks are idempotent and restartable.</span></span>
7. <span data-ttu-id="aef3a-296">작업 호출이 성공할 때까지 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-296">Continue to invoke operations until they succeed.</span></span>
8. <span data-ttu-id="aef3a-297">자동 크기 조정 전략을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-297">Consider autoscaling strategies.</span></span>

### <a name="virtual-machines"></a><span data-ttu-id="aef3a-298">Virtual Machines</span><span class="sxs-lookup"><span data-stu-id="aef3a-298">Virtual Machines</span></span>
1. <span data-ttu-id="aef3a-299">이 문서의 Virtual Machines 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-299">Review the Virtual Machines section of this document.</span></span>
2. <span data-ttu-id="aef3a-300">영구 저장소에 D 드라이브를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-300">Do not use drive D for persistent storage.</span></span>
3. <span data-ttu-id="aef3a-301">가용성 집합에 서비스 계층의 컴퓨터를 그룹화합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-301">Group machines in a service tier into an availability set.</span></span>
4. <span data-ttu-id="aef3a-302">부하 분산 및 선택적 프로브를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-302">Configure load balancing and optional probes.</span></span>

### <a name="storage"></a><span data-ttu-id="aef3a-303">Storage</span><span class="sxs-lookup"><span data-stu-id="aef3a-303">Storage</span></span>
1. <span data-ttu-id="aef3a-304">이 문서의 저장소 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-304">Review the Storage section of this document.</span></span>
2. <span data-ttu-id="aef3a-305">데이터 또는 대역폭이 할당량을 초과하는 경우 여러 저장소 계정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-305">Use multiple storage accounts when data or bandwidth exceeds quotas.</span></span>

### <a name="sql-database"></a><span data-ttu-id="aef3a-306">SQL Database</span><span class="sxs-lookup"><span data-stu-id="aef3a-306">SQL Database</span></span>
1. <span data-ttu-id="aef3a-307">이 문서의 SQL Database 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-307">Review the SQL Database section of this document.</span></span>
2. <span data-ttu-id="aef3a-308">재시도 정책을 구현하여 임시 오류를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-308">Implement a retry policy to handle transient errors.</span></span>
3. <span data-ttu-id="aef3a-309">분할을 규모 확장 전략으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-309">Use partitioning/sharding as a scale-out strategy.</span></span>

### <a name="sql-server-on-virtual-machines"></a><span data-ttu-id="aef3a-310">Virtual Machines의 SQL Server</span><span class="sxs-lookup"><span data-stu-id="aef3a-310">SQL Server on Virtual Machines</span></span>
1. <span data-ttu-id="aef3a-311">이 문서의 Virtual Machines에서 SQL Server 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-311">Review the SQL Server on Virtual Machines section of this document.</span></span>
2. <span data-ttu-id="aef3a-312">Virtual Machines에 대한 이전의 권장 사항을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-312">Follow the previous recommendations for Virtual Machines.</span></span>
3. <span data-ttu-id="aef3a-313">AlwaysOn과 같은 SQL Server 고가용성 기능을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-313">Use SQL Server high availability features, such as AlwaysOn.</span></span>

### <a name="service-bus"></a><span data-ttu-id="aef3a-314">Service Bus</span><span class="sxs-lookup"><span data-stu-id="aef3a-314">Service Bus</span></span>
1. <span data-ttu-id="aef3a-315">이 문서의 Service Bus 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-315">Review the Service Bus section of this document.</span></span>
2. <span data-ttu-id="aef3a-316">백업으로 내구성이 있는 클라이언트 쪽 큐를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-316">Consider creating a durable client-side queue as a backup.</span></span>

### <a name="hdinsight"></a><span data-ttu-id="aef3a-317">HDInsight</span><span class="sxs-lookup"><span data-stu-id="aef3a-317">HDInsight</span></span>
1. <span data-ttu-id="aef3a-318">이 문서의 HDInsight 섹션을 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-318">Review the HDInsight section of this document.</span></span>
2. <span data-ttu-id="aef3a-319">로컬 오류에 필요한 추가 가용성 단계가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="aef3a-319">No additional availability steps are required for local failures.</span></span>

