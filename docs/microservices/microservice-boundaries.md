---
title: "마이크로 서비스 경계 식별"
description: "마이크로 서비스 경계 식별"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: e4f11da9f970724c55ad99824f808a10c4558971
ms.sourcegitcommit: 744ad1381e01bbda6a1a7eff4b25e1a337385553
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/08/2018
---
# <a name="designing-microservices-identifying-microservice-boundaries"></a><span data-ttu-id="e650e-103">마이크로 서비스 디자인: 마이크로 서비스 경계 식별</span><span class="sxs-lookup"><span data-stu-id="e650e-103">Designing microservices: Identifying microservice boundaries</span></span>

<span data-ttu-id="e650e-104">마이크로 서비스에 적절한 크기는 얼마인가요?</span><span class="sxs-lookup"><span data-stu-id="e650e-104">What is the right size for a microservice?</span></span> <span data-ttu-id="e650e-105">"너무 크지도 작지도 않은 것"이 효과가 있다고들 하며 &mdash;이것이 물론 맞는 말이지만 실제로는 별로 도움이 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-105">You often hear something to the effect of, "not too big and not too small" &mdash; and while that's certainly correct, it's not very helpful in practice.</span></span> <span data-ttu-id="e650e-106">하지만 신중하게 디자인한 도메인 모델을 사용하여 시작하면 마이크로 서비스를 사용하는 이유를 쉽게 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-106">But if you start from a carefully designed domain model, it's much easier to reason about microservices.</span></span>

![](./images/bounded-contexts.png)

## <a name="from-domain-model-to-microservices"></a><span data-ttu-id="e650e-107">도메인 모델에서 마이크로 서비스로</span><span class="sxs-lookup"><span data-stu-id="e650e-107">From domain model to microservices</span></span>

<span data-ttu-id="e650e-108">[이전 챕터](./domain-analysis.md)에서는 드론 배달 응용 프로그램의 바인딩된 컨텍스트 집합을 정의했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-108">In the [previous chapter](./domain-analysis.md), we defined a set of bounded contexts for the Drone Delivery application.</span></span> <span data-ttu-id="e650e-109">그런 다음 바인딩된 컨텍스트 중 하나인 배송(Shipping) 바인딩된 컨텍스트를 자세히 살펴보고 바인딩된 컨텍스트에 대한 엔터티 집합, 집계 및 도메인 서비스를 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-109">Then we looked more closely at one of these bounded contexts, the Shipping bounded context, and identified a set of entities, aggregates, and domain services for that bounded context.</span></span>

<span data-ttu-id="e650e-110">이제 도메인 모델에서 응용 프로그램 디자인으로 이동할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-110">Now we're ready to go from domain model to application design.</span></span> <span data-ttu-id="e650e-111">다음은 도메인 모델에서 마이크로 서비스를 파생시키는 데 사용할 수 있는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-111">Here's an approach that you can use to derive microservices from the domain model.</span></span>

1. <span data-ttu-id="e650e-112">바인딩된 컨텍스트로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-112">Start with a bounded context.</span></span> <span data-ttu-id="e650e-113">일반적으로 마이크로 서비스의 기능은 둘 이상의 바인딩된 컨텍스트에 걸쳐 있지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-113">In general, the functionality in a microservice should not span more than one bounded context.</span></span> <span data-ttu-id="e650e-114">정의에 따라 바인딩된 컨텍스트는 특정 도메인 모델의 경계를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-114">By definition, a bounded context marks the boundary of a particular domain model.</span></span> <span data-ttu-id="e650e-115">마이크로 서비스가 서로 다른 도메인 모델을 함께 혼합한다는 것을 알게 되면, 다시 돌아가서 도메인 분석을 구체화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-115">If you find that a microservice mixes different domain models together, that's a sign that you may need to go back and refine your domain analysis.</span></span>

2. <span data-ttu-id="e650e-116">그런 다음 도메인 모델에서 집계를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-116">Next, look at the aggregates in your domain model.</span></span> <span data-ttu-id="e650e-117">집계는 마이크로 서비스에 적합한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-117">Aggregates are often good candidates for microservices.</span></span> <span data-ttu-id="e650e-118">잘 설계된 집계에는 다음과 같이 잘 설계된 마이크로 서비스의 특징이 많이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-118">A well-designed aggregate exhibits many of the characteristics of a well-designed microservice, such as:</span></span>

    - <span data-ttu-id="e650e-119">집계는 데이터 액세스나 메시징과 같은 기술적인 문제보다는 비즈니스 요구 사항에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-119">An aggregates is derived from business requirements, rather than technical concerns such as data access or messaging.</span></span>  
    - <span data-ttu-id="e650e-120">집계에는 높은 기능적 응집력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-120">An aggregate should have high functional cohesion.</span></span>
    - <span data-ttu-id="e650e-121">집계는 지속성에 대한 경계입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-121">An aggregate is a boundary of persistence.</span></span>
    - <span data-ttu-id="e650e-122">집계는 느슨하게 결합되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-122">Aggregates should be loosely coupled.</span></span> 
    
3. <span data-ttu-id="e650e-123">도메인 서비스 역시 마이크로 서비스에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-123">Domain services are also good candidates for microservices.</span></span> <span data-ttu-id="e650e-124">도메인 서비스는 여러 집계에 걸쳐 있는 상태 비저장 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-124">Domain services are stateless operations across multiple aggregates.</span></span> <span data-ttu-id="e650e-125">일반적인 예는 여러 마이크로 서비스가 관련된 워크플로입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-125">A typical example is a workflow that involves several microservices.</span></span> <span data-ttu-id="e650e-126">이러한 예를 드론 배달 응용 프로그램에서 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-126">We'll see an example of this in the Drone Delivery application.</span></span>

4. <span data-ttu-id="e650e-127">마지막으로 비기능적인 요구 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-127">Finally, consider non-functional requirements.</span></span> <span data-ttu-id="e650e-128">팀 규모, 데이터 유형, 기술, 확장성 요구 사항, 가용성 요구 사항 및 보안 요구 사항과 같은 요소를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-128">Look at factors such as team size, data types, technologies, scalability requirements, availability requirements, and security requirements.</span></span> <span data-ttu-id="e650e-129">이러한 요소로 인해 마이크로 서비스를 둘 이상의 더 작은 서비스로 분해하거나 그 반대의 작업을 수행하고 여러 마이크로 서비스를 하나로 결합해야 하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-129">These factors may lead you to further decompose a microservice into two or more smaller services, or do the opposite and combine several microservices into one.</span></span> 

<span data-ttu-id="e650e-130">응용 프로그램에서 마이크로 서비스를 확인한 후 다음 기준에 따라 디자인을 유효성을 검증합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-130">After you identify the microservices in your application, validate your design against the following criteria:</span></span>

- <span data-ttu-id="e650e-131">각 서비스에는 단일 책임이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-131">Each service has a single responsibility.</span></span>
- <span data-ttu-id="e650e-132">서비스 간에 번잡한 호출이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-132">There are no chatty calls between services.</span></span> <span data-ttu-id="e650e-133">기능을 두 개의 서비스로 나눠서 과도하게 번잡한 호출이 발생하는 경우, 해당 서비스가 동일한 서비스에 속한다는 징후일 수 입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-133">If splitting functionality into two services causes them to be overly chatty, it may be a symptom that these functions belong in the same service.</span></span>
- <span data-ttu-id="e650e-134">각 서비스는 소규모 팀이 독립적으로 작업할 수 있을 정도로 충분히 작습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-134">Each service is small enough that it can be built by a small team working independently.</span></span>
- <span data-ttu-id="e650e-135">둘 이상의 서비스를 잠금 단계에서 배포해야 하는 상호 종속성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-135">There are no inter-dependencies that will require two or more services to be deployed in lock-step.</span></span> <span data-ttu-id="e650e-136">다른 서비스를 다시 배포하지 않고도 서비스를 배포하는 것이 항상 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-136">It should always be possible to deploy a service without redeploying any other services.</span></span>
- <span data-ttu-id="e650e-137">서비스는 밀접하게 결합되어 있지 않으며 독립적으로 진화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-137">Services are not tightly coupled, and can evolve independently.</span></span>
- <span data-ttu-id="e650e-138">서비스 경계로 인해 데이터 일관성이나 무결성에 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-138">Your service boundaries will not create problems with data consistency or integrity.</span></span> <span data-ttu-id="e650e-139">경우에 따라 단일 마이크로 서비스에 기능을 입력하여 데이터 일관성을 유지하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-139">Sometimes it's important to maintain data consistency by putting functionality into a single microservice.</span></span> <span data-ttu-id="e650e-140">즉, 강력한 일관성이 정말 필요한지 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-140">That said, consider whether you really need strong consistency.</span></span> <span data-ttu-id="e650e-141">분산 시스템의 최종 일관성을 해결하기 위한 전략이 있으며, 서비스를 분해하는 이점이 최종 일관성을 관리하는 어려움보다 큰 경우가 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-141">There are strategies for addressing eventual consistency in a distributed system, and the benefits of decomposing services often outweigh the challenges of managing eventual consistency.</span></span>

<span data-ttu-id="e650e-142">무엇보다 실용적인 디자인이 중요하며 도메인 기반 디자인은 반복적인 프로세스라는 것을 기억해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-142">Above all, it's important to be pragmatic, and remember that domain-driven design is an iterative process.</span></span> <span data-ttu-id="e650e-143">의문이 있으면 정교하지 않은 마이크로 서비스로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-143">When in doubt, start with more coarse-grained microservices.</span></span> <span data-ttu-id="e650e-144">마이크로 서비스를 두 개의 작은 서비스로 나누는 것이 기존의 여러 마이크로 서비스에서 기능을 리팩터링하는 것보다 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-144">Splitting a microservice into two smaller services is easier than refactoring functionality across several existing microservices.</span></span>
  
## <a name="drone-delivery-defining-the-microservices"></a><span data-ttu-id="e650e-145">드론 배달: 마이크로 서비스 정의</span><span class="sxs-lookup"><span data-stu-id="e650e-145">Drone Delivery: Defining the microservices</span></span>

<span data-ttu-id="e650e-146">앞에서 개발 팀은 &mdash;배달, 패키지, 드론 및 계정&mdash;이라는 네 가지 집계와 Scheduler 및 감독자라는 두 가지 도메인 서비스를 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-146">Recall that the development team had identified the four aggregates &mdash; Delivery, Package, Drone, and Account &mdash; and two domain services, Scheduler and Supervisor.</span></span> 

<span data-ttu-id="e650e-147">배달 및 패키지는 마이크로 서비스가 될만한 명백한 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-147">Delivery and Package are obvious candidates for microservices.</span></span> <span data-ttu-id="e650e-148">Scheduler와 감독자는 다른 마이크로 서비스가 수행하는 작업을 조정하기 때문에 이러한 도메인 서비스를 마이크로 서비스로 구현하는 것이 타당합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-148">The Scheduler and Supervisor coordinate the activities performed by other microservices, so it makes sense to implement these domain services as microservices.</span></span>  

<span data-ttu-id="e650e-149">드론 및 계정은 다른 바인딩된 컨텍스트에 속하기 때문에 고려할 필요가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-149">Drone and Account are interesting because they belong to other bounded contexts.</span></span> <span data-ttu-id="e650e-150">Scheduler에 대한 한가지 옵션은 드론 및 계정 바인딩된 컨텍스트를 직접 호출하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-150">One option is for the Scheduler to call the Drone and Account bounded contexts directly.</span></span> <span data-ttu-id="e650e-151">또 다른 옵션은 배송(Shipping) 바인딩된 컨텍스트 내에 드론 및 계정 마이크로 서비스를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-151">Another option is to create Drone and Account microservices inside the Shipping bounded context.</span></span> <span data-ttu-id="e650e-152">이러한 마이크로 서비스는 배송 컨텍스트에 적합한 API 또는 데이터 스키마를 노출하여 바인딩된 컨텍스트 사이에서 중재를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-152">These microservices would mediate between the bounded contexts, by exposing APIs or data schemas that are more suited to the Shipping context.</span></span>

<span data-ttu-id="e650e-153">드론 및 계정 바인딩된 컨텍스트의 세부 정보는 이 가이드의 범위를 벗어나기 때문에 이에 대한 모의 서비스를 참조 구현에 만들어 두었습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-153">The details of the Drone and Account bounded contexts are beyond the scope of this guidance, so we created mock services for them in our reference implementation.</span></span> <span data-ttu-id="e650e-154">하지만 이런 상황에서 고려할 몇 가지 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-154">But here are some factors to consider in this situation:</span></span>

- <span data-ttu-id="e650e-155">다른 바인딩된 컨텍스트로 직접 호출하는 네트워크 오버헤드는 얼마나 되나요?</span><span class="sxs-lookup"><span data-stu-id="e650e-155">What is the network overhead of calling directly into the other bounded context?</span></span> 

- <span data-ttu-id="e650e-156">다른 바인딩된 컨텍스트의 데이터 스키마가 이 컨텍스트에 적합한가요? 아니면 이 바인딩된 컨텍스트에 맞는 스키마를 두는 것이 더 좋은가요?</span><span class="sxs-lookup"><span data-stu-id="e650e-156">Is the data schema for the other bounded context suitable for this context, or is it better to have a schema that's tailored to this bounded context?</span></span> 

- <span data-ttu-id="e650e-157">다른 바인딩된 컨텍스트는 레거시 시스템인가요?</span><span class="sxs-lookup"><span data-stu-id="e650e-157">Is the other bounded context a legacy system?</span></span> <span data-ttu-id="e650e-158">그렇다면 레거시 시스템과 최신 응용 프로그램 사이에서 변환을 수행하여 [손상 방지 레이어](../patterns/anti-corruption-layer.md) 역할을 하는 서비스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-158">If so, you might create a service that acts as an [anti-corruption layer](../patterns/anti-corruption-layer.md) to translate between the legacy system and the modern application.</span></span> 

- <span data-ttu-id="e650e-159">팀 구조는 어떤가요?</span><span class="sxs-lookup"><span data-stu-id="e650e-159">What is the team structure?</span></span> <span data-ttu-id="e650e-160">다른 바인딩된 컨텍스트를 담당하는 팀과 통신하기가 쉽나요?</span><span class="sxs-lookup"><span data-stu-id="e650e-160">Is it easy to communicate with the team that's responsible for the other bounded context?</span></span> <span data-ttu-id="e650e-161">그렇지 않은 경우 두 컨텍스트 사이에서 중재를 수행하는 서비스를 만들면 팀 간 통신 비용을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-161">If not, creating a service that mediates between the two contexts can help to mitigate the cost of cross-team communication.</span></span>

<span data-ttu-id="e650e-162">지금까지는 비기능적인 요구 사항을 고려하지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-162">So far, we haven't considered any non-functional requirements.</span></span> <span data-ttu-id="e650e-163">응용 프로그램의 처리량 요구 사항을 고려하여, 개발 팀은 클라이언트 요청에 대한 집계를 담당하는 별도의 집계 마이크로 서비스를 만들기로 결정했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-163">Thinking about the application's throughput requirements, the development team decided to create a separate Ingestion microservice that is responsible for ingesting client requests.</span></span> <span data-ttu-id="e650e-164">이 마이크로 서비스는 들어오는 요청을 처리용 버퍼에 넣어서 [부하 평준화](../patterns/queue-based-load-leveling.md)를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-164">This microservice will implement [load leveling](../patterns/queue-based-load-leveling.md) by putting incoming requests into a buffer for processing.</span></span> <span data-ttu-id="e650e-165">Scheduler는 버퍼에서 요청을 읽고 워크플로를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-165">The Scheduler will read the requests from the buffer and execute the workflow.</span></span> 

<span data-ttu-id="e650e-166">비기능적인 요구 사항으로 인해 팀에서 하나의 서비스를 추가로 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-166">Non-functional requirements led the team to create one additional service.</span></span> <span data-ttu-id="e650e-167">여태까지 모든 서비스는 실시간으로 패키지를 예약하고 전달하는 프로세스에 관한 서비스였습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-167">All of the services so far have been about the process of scheduling and delivering packages in real time.</span></span> <span data-ttu-id="e650e-168">시스템은 데이터 분석을 위해 장기 저장소에 모든 배달 기록을 저장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-168">But the system also needs to store the history of every delivery in long-term storage for data analysis.</span></span> <span data-ttu-id="e650e-169">팀에서는 이것을 배달 서비스 담당으로 간주했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-169">The team considered making this the responsibility of the Delivery service.</span></span> <span data-ttu-id="e650e-170">하지만 기록 분석을 위한 데이터 저장소 요구 사항은 처리 중인 작업을 위한 데이터 저장소 요구 사항과 매우 다릅니다([데이터 고려 사항](./data-considerations.md) 참조).</span><span class="sxs-lookup"><span data-stu-id="e650e-170">However, the data storage requirements are quite different for historical analysis versus in-flight operations (see [Data considerations](./data-considerations.md)).</span></span> <span data-ttu-id="e650e-171">그래서 팀은 배달 서비스의 DeliveryTracking 이벤트를 수신 대기하고 장기 저장소에 이벤트를 작성하는 별도의 Delivery History(배달 기록) 서비스를 만들기로 결정했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-171">Therefore, the team decided to create a separate Delivery History service, which will listen for DeliveryTracking events from the Delivery service and write the events into long-term storage.</span></span>

<span data-ttu-id="e650e-172">다음 다이어그램은 현 시점의 디자인입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-172">The following diagram shows the design at this point:</span></span>
 
![](./images/microservices.png)

## <a name="choosing-a-compute-option"></a><span data-ttu-id="e650e-173">계산 옵션 선택</span><span class="sxs-lookup"><span data-stu-id="e650e-173">Choosing a compute option</span></span>

<span data-ttu-id="e650e-174">*계산*이라는 용어는 응용 프로그램이 실행되는 계산 리소스의 호스팅 모델을 말합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-174">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="e650e-175">마이크로 서비스 아키텍처의 경우 두 가지 접근 방식이 특히 많이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-175">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="e650e-176">전용 노드(VM)에서 실행되는 서비스를 관리하는 서비스 오케스트레이터</span><span class="sxs-lookup"><span data-stu-id="e650e-176">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="e650e-177">FaaS(functions as a service)를 사용하고 서버를 사용하지 않는 아키텍처</span><span class="sxs-lookup"><span data-stu-id="e650e-177">A serverless architecture using functions as a service (FaaS).</span></span> 

<span data-ttu-id="e650e-178">이것이 유일한 옵션은 아니지만, 마이크로 서비스 구축을 위해 검증된 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-178">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="e650e-179">응용 프로그램에 두 가지 방법이 모두 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-179">An application might include both approaches.</span></span>

### <a name="service-orchestrators"></a><span data-ttu-id="e650e-180">서비스 오케스트레이터</span><span class="sxs-lookup"><span data-stu-id="e650e-180">Service orchestrators</span></span>

<span data-ttu-id="e650e-181">오케스트레이터는 서비스 집합 배포 및 관리와 관련된 작업을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-181">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="e650e-182">이러한 작업에는 노드에 서비스 배치, 서비스 상태 모니터링, 비정상 서비스 다시 시작, 서비스 인스턴스 사이에서 네트워크 트래픽 부하 조정, 서비스 검색, 서비스 인스턴스 수의 규모 조정, 구성 업데이트 적용이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-182">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="e650e-183">많이 사용되는 오케스트레이터에는 Kubernetes, DC/OS, Docker Swarm 및 Service Fabric이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-183">Popular orchestrators include Kubernetes, DC/OS, Docker Swarm, and Service Fabric.</span></span> 

- <span data-ttu-id="e650e-184">[ACS](/azure/container-service/)(Azure Container Service)는 프로덕션이 준비된 Kubernetes, DC/OS 또는 Docker Swarm 클러스터를 빠르게 배포할 수 있는 Azure 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-184">[Azure Container Service](/azure/container-service/) (ACS) is an Azure service that lets you deploy a production-ready Kubernetes, DC/OS, or Docker Swarm cluster.</span></span>

- <span data-ttu-id="e650e-185">[AKS(Azure Container Service)](/azure/aks/)는 관리되는 Kubernetes 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-185">[AKS (Azure Container Service)](/azure/aks/) is a managed Kubernetes service.</span></span> <span data-ttu-id="e650e-186">AKS는 Kubernetes를 프로비전하고 Kubernetes API 엔드포인트를 노출하지만 Kubernetes 제어 플레인을 호스트 및 관리하고 자동 업그레이드, 자동 패치 적용, 자동 크기 조정 및 기타 관리 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-186">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="e650e-187">AKS를 "서비스로 제공되는 Kubernetes API"라고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-187">You can think of AKS as being "Kubernetes APIs as a service."</span></span> <span data-ttu-id="e650e-188">이 문서 작성 시점에 AKS는 아직 미리 보기 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-188">At the time of writing, AKS is still in preview.</span></span> <span data-ttu-id="e650e-189">AKS는 Azure에서 Kubernetes를 실행하는 데 많이 사용하는 방법이 될 것으로 예상됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-189">However, it's expected that AKS will become the preferred way to run Kubernetes in Azure.</span></span> 

- <span data-ttu-id="e650e-190">[Service Fabric](/azure/service-fabric/)은 마이크로 서비스를 패키징, 배포 및 관리하기 위한 분산 시스템 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-190">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="e650e-191">마이크로 서비스는 Service Fabric에 컨테이너, 이진 실행 파일 또는 [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction)로 배포될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-191">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="e650e-192">Reliable Services 프로그래밍 모델을 사용하면, 서비스에서 Service Fabric 프로그래밍 API를 직접 사용하여 시스템을 쿼리하고, 상태를 보고하고, 구성 및 코드 변경에 대한 알림을 받고, 다른 서비스를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-192">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="e650e-193">Service Fabric을 통한 주요 차별화는 [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections)를 사용하여 상태 저장 서비스를 구축하는 데 강력하게 집중하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-193">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

### <a name="containers"></a><span data-ttu-id="e650e-194">컨테이너</span><span class="sxs-lookup"><span data-stu-id="e650e-194">Containers</span></span>

<span data-ttu-id="e650e-195">컨테이너와 마이크로 서비스가 같은 것처럼 말하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-195">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="e650e-196">그것은 사실이 아니며 &mdash;마이크로 서비스를 만드는 데는 컨테이너가 필요하지 않습니다.&mdash; 컨테이너에는 마이크로 서비스에 특히 적합한 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-196">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="e650e-197">**이식성**.</span><span class="sxs-lookup"><span data-stu-id="e650e-197">**Portability**.</span></span> <span data-ttu-id="e650e-198">컨테이너 이미지는 라이브러리나 다른 종속성을 설치할 필요 없이 실행되는 독립 실행형 패키지입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-198">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="e650e-199">따라서 배포가 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-199">That makes them easy to deploy.</span></span> <span data-ttu-id="e650e-200">컨테이너는 신속하게 시작하고 중지할 수 있기 때문에 부하를 더 많이 처리하거나 노드 장애를 복구하도록 새로운 인스턴스를 스핀업할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-200">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span> 

- <span data-ttu-id="e650e-201">**밀도**.</span><span class="sxs-lookup"><span data-stu-id="e650e-201">**Density**.</span></span> <span data-ttu-id="e650e-202">컨테이너는 OS 리소스를 공유하기 때문에 가상 머신을 실행하는 것보다 경량입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-202">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="e650e-203">여러 컨테이너를 단일 노드로 묶는 것이 가능하기 때문에 다수의 소규모 서비스로 구성된 응용 프로그램에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-203">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="e650e-204">**리소스 격리**.</span><span class="sxs-lookup"><span data-stu-id="e650e-204">**Resource isolation**.</span></span> <span data-ttu-id="e650e-205">컨테이너에서 사용할 수 있는 메모리 및 CPU 양을 제한할 수 있기 때문에 런어웨이 프로세스가 호스트 리소스를 소진하지 않도록 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-205">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="e650e-206">자세한 내용은 [격벽 패턴](../patterns/bulkhead.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e650e-206">See the [Bulkhead Pattern](../patterns/bulkhead.md) for more information.</span></span>

### <a name="serverless-functions-as-a-service"></a><span data-ttu-id="e650e-207">서버리스(Functions as a Service)</span><span class="sxs-lookup"><span data-stu-id="e650e-207">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="e650e-208">서버리스 아키텍처에서는 VM 또는 가상 네트워크 인프라를 관리하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-208">With a serverless architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="e650e-209">대신, 사용자가 코드를 배포하면 호스팅 서비스가 해당 코드를 VM에 넣고 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-209">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="e650e-210">이 방법은 이벤트 기반 트리거를 사용하여 조율하는 소규모의 세분화된 함수를 선호하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-210">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="e650e-211">예를 들어 큐에 배치된 메시지는 큐에서 읽고 메시지를 처리하는 함수를 트리거 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-211">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="e650e-212">[Azure Functions][functions]는 HTTP 요청, Service Bus 큐 및 Event Hubs를 비롯한 다양한 함수 트리거를 지원하는 서버리스 계산 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-212">[Azure Functions][functions] is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="e650e-213">전체 목록은 [Azure Functions 트리거 및 바인딩 개념][functions-triggers]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e650e-213">For a complete list, see [Azure Functions triggers and bindings concepts][functions-triggers].</span></span> <span data-ttu-id="e650e-214">Azure에서 관리되는 이벤트 라우팅 서비스인 [Azure Event Grid][event-grid]도 살펴보세요.</span><span class="sxs-lookup"><span data-stu-id="e650e-214">Also consider [Azure Event Grid][event-grid], which is a managed event routing service in Azure.</span></span>

### <a name="orchestrator-or-serverless"></a><span data-ttu-id="e650e-215">오케스트레이터 또는 서버리스</span><span class="sxs-lookup"><span data-stu-id="e650e-215">Orchestrator or serverless?</span></span>

<span data-ttu-id="e650e-216">오케스트레이터 방식과 서버리스 방식 중에서 선택할 때 고려해야 할 몇 가지 요소가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-216">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="e650e-217">**관리 효율성** 플랫폼이 모든 계산 리소스를 관리하기 때문에 서버리스 애플리케이션은 관리가 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-217">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="e650e-218">오케스트레이터는 클러스터 관리 및 구성의 일부 측면을 추상화하지만 기본 VM은 완전히 숨기지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-218">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="e650e-219">오케스트레이터를 사용하면 부하 분산, CPU 및 메모리 사용량 및 네트워킹과 같은 문제에 대해 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-219">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="e650e-220">**유연성 및 제어**.</span><span class="sxs-lookup"><span data-stu-id="e650e-220">**Flexibility and control**.</span></span> <span data-ttu-id="e650e-221">오케스트레이터를 사용하면 서비스와 클러스터를 구성하고 관리하는 데 있어 많은 제어가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-221">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="e650e-222">단점은 복잡성이 추가되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-222">The tradeoff is additional complexity.</span></span> <span data-ttu-id="e650e-223">서버리스 아키텍처를 사용하면 이러한 세부 사항이 추상화되기 때문에 제어를 어느 정도 포기해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-223">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="e650e-224">**이식성**.</span><span class="sxs-lookup"><span data-stu-id="e650e-224">**Portability**.</span></span> <span data-ttu-id="e650e-225">여기에 나열된 모든 오케스트레이터(Kubernetes, DC/OS, Docker Swarm 및 Service Fabric)는 온-프레미스 또는 다수의 공용 클라우드에서 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-225">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span> 

<span data-ttu-id="e650e-226">**응용 프로그램 통합**.</span><span class="sxs-lookup"><span data-stu-id="e650e-226">**Application integration**.</span></span> <span data-ttu-id="e650e-227">서버리스 아키텍처를 사용하면 복잡한 응용 프로그램을 개발하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-227">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="e650e-228">Azure의 한 가지 옵션은 [Azure Logic Apps](/azure/logic-apps/)를 사용하여 Azure Functions 집합을 조정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-228">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="e650e-229">이러한 방법에 대한 예제는 [Azure Logic Apps와 통합하는 함수 만들기](/azure/azure-functions/functions-twitter-email)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e650e-229">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="e650e-230">**비용**.</span><span class="sxs-lookup"><span data-stu-id="e650e-230">**Cost**.</span></span> <span data-ttu-id="e650e-231">오케스트레이터를 사용하면 클러스터에서 실행 중인 VM에 대한 비용을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-231">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="e650e-232">서버리스 응용 프로그램을 사용하면 소비한 실제 계산 리소스에 대해서만 비용을 지불합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-232">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="e650e-233">두 경우 모두 저장소, 데이터베이스 및 메시징 서비스와 같은 추가 서비스에 대한 비용을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-233">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="e650e-234">**확장성**.</span><span class="sxs-lookup"><span data-stu-id="e650e-234">**Scalability**.</span></span> <span data-ttu-id="e650e-235">Azure Functions는 들어오는 이벤트 수를 기반으로 수요에 맞게 자동으로 규모가 조정됩니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-235">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="e650e-236">오케스트레이터를 사용하면 클러스터에서 실행 중인 서비스 인스턴스의 수를 늘려서 규모를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-236">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="e650e-237">클러스터에 VM을 더 추가하여 확장할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-237">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="e650e-238">참조 구현에는 주로 Kubernetes를 사용했지만 한 가지 서비스 즉, Delivery History(배달 기록) 서비스에 대해서는 Azure Functions를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-238">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="e650e-239">Azure Functions는 이벤트 기반 워크로드이기 때문에 이러한 특정 서비스에 적합합니다</span><span class="sxs-lookup"><span data-stu-id="e650e-239">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="e650e-240">Event Hubs 트리거를 사용하여 함수를 호출하면 서비스에 최소한의 코드만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-240">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="e650e-241">Delivery History(배달 기록) 서비스는 기본 워크플로에 속하지 않으므로 Kubernetes 클러스터 외부에서 실행하면 사용자가 시작한 작업의 종단 간 대기 시간에 영향을 미치지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e650e-241">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span> 

> [!div class="nextstepaction"]
> [<span data-ttu-id="e650e-242">데이터 고려 사항</span><span class="sxs-lookup"><span data-stu-id="e650e-242">Data considerations</span></span>](./data-considerations.md)

<!-- links -->

[acs-engine]: https://github.com/Azure/acs-engine
[acs-faq]: /azure/container-service/dcos-swarm/container-service-faq
[event-grid]: /azure/event-grid/
[functions]: /azure/azure-functions/functions-overview
[functions-triggers]: /azure/azure-functions/functions-triggers-bindings
