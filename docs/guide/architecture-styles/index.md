---
title: 아키텍처 스타일
description: 클라우드 응용 프로그램에 대한 공통 아키텍처 스타일
layout: LandingPage
ms.openlocfilehash: 15a316f9ebf7cfe4e72a6992f264a68abb904819
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/14/2017
---
# <a name="architecture-styles"></a>아키텍처 스타일

*아키텍처 스타일*은 특정 특성을 공유하는 아키텍처 제품군입니다. 예를 들어 [N 계층][n-tier]은 공통 아키텍처 스타일입니다. 최근에는 [마이크로 서비스 아키텍처][microservices]가 각광을 받기 시작했습니다. 아키텍처 스타일은 특정 기술 사용할 필요가 없지만, 일부 기술은 특정 아키텍처와 잘 어울립니다. 예를 들어 컨테이너는 기본적으로 마이크로 서비스와 잘 어울립니다.  

우리는 클라우드 응용 프로그램에서 흔히 발견되는 아키텍처 스타일 집합을 확인했습니다. 각 스타일에 대한 문서의 내용은 다음과 같습니다.

- 스타일에 대한 설명 및 논리 다이어그램.
- 스타일 선택 시기 추천.
- 이점, 과제 및 모범 사례.
- 관련 Azure 서비스를 사용하는 권장 배포.


## <a name="a-quick-tour-of-the-styles"></a>스타일 둘러보기   

이 섹션에서는 우리가 확인한 아키텍처 스타일 및 각 아키텍처 스타일을 사용할 때 고려해야 할 주요 사항을 신속하게 살펴보겠습니다. 연결된 항목에서 자세한 내용을 읽어 보세요.

### <a name="n-tier"></a>N 계층

<img src="./images/n-tier-sketch.svg" style="float:left; margin-top:6px;"/>

**[N 계층][n-tier]**은 엔터프라이즈 응용 프로그램에 사용되는 전통적인 아키텍처입니다. 종속성은 응용 프로그램을 프레젠테이션, 비즈니스 논리, 데이터 액세스 등의 논리 함수를 수행하는 *레이어*로 분할하여 관리됩니다. 레이어는 그 아래에 있는 레이어만 호출할 수 있습니다. 그러나 이와 같은 가로 방향 레이어는 문제가 될 수 있습니다. 응용 프로그램의 나머지 부분을 건드리지 않고 한 부분에만 변경 내용을 적용하기가 어려울 수 있습니다. 따라서 자주 업데이트하기가 어렵기 때문에 새 기능을 신속하게 추가할 수 없습니다.

N 계층은 기본적으로 이미 계층화된 아키텍처를 사용하는 기존 응용 프로그램 마이그레이션에 적합합니다. 이러한 이유로 IaaS(Infrastructure as a Service) 솔루션 또는 IaaS와 관리 서비스를 혼용하는 응용 프로그램에서 가장 많이 목격되는 것이 N 계층입니다. 

### <a name="web-queue-worker"></a>웹-큐-작업자

<img src="./images/web-queue-worker-sketch.svg" style="float:left; margin-top:6px;"/>

순수한 PaaS 솔루션을 개발하려면 **[웹-큐-작업자](./web-queue-worker.md)** 아키텍처를 고려해 보세요. 이 스타일의 경우 응용 프로그램의 웹 프런트 엔드는 HTTP 요청을 처리하고 백 엔드 작업자는 CPU 집약적인 작업이나 장기 실행 작업을 수행합니다. 프런트 엔드는 비동기 메시지 큐를 통해 작업자와 통신합니다. 

웹-큐-작업자는 리소스 집약적 작업이 약간 있는 비교적 단순한 도메인에 적합합니다. N 계층과 마찬가지로, 이 아키텍처는 이해하기 쉽습니다. 관리 서비스를 사용하면 배포 및 운영이 간단합니다. 하지만 복잡한 도메인의 경우 종속성 관리가 어려울 수 있습니다. 프런트 엔드 및 작업자가 유지 관리 및 업데이트가 어려운 한 덩어리의 커다란 구성 요소로 변하기 십상입니다. N 계층과 마찬가지로, 이로 인해 업데이트 빈도가 줄어들고 혁신을 제한할 수 있습니다.

### <a name="microservices"></a>마이크로 서비스

<img src="./images/microservices-sketch.svg" style="float:left; margin-top:6px;"/>

응용 프로그램에 복잡한 도메인이 있는 경우 **[마이크로 서비스][microservices]** 아키텍처로 전환하는 것을 고려해 보세요. 마이크로 서비스 응용 프로그램은 여러 작은 독립 서비스로 구성됩니다. 각 서비스는 단일 비즈니스 기능을 구현합니다. 서비스는 느슨하게 결합되며, API 계약을 통해 통신합니다.

각 서비스를 소규모 집중 개발 팀에서 개발할 수 있습니다. 팀 간에 조정 절차를 많이 거치지 않고 개별 서비스를 배포할 수 있기 때문에 업데이트를 자주 할 수 있습니다. 마이크로 서비스 아키텍처는 N 계층 또는 웹-큐-작업자보다 빌드 및 관리 방법이 좀 더 복잡합니다. 성숙한 개발 및 DevOps 문화가 필요합니다. 하지만 이 스타일을 제대로 수행하기만 한다면 보다 빠른 릴리스 개발속도, 보다 빠른 혁신, 보다 복원력 있는 아키텍처로 이어질 수 있습니다. 

### <a name="cqrs"></a>CQRS

<img src="./images/cqrs-sketch.svg" style="float:left; margin-top:6px;"/>

**[CQRS](./cqrs.md)**(명령 및 쿼리 책임 분리) 스타일은 읽기 및 쓰기 작업을 별도의 모델로 분리합니다. 이렇게 하여 시스템에서 데이터를 업데이트하는 부분을 데이터를 읽는 부분과 격리합니다. 뿐만 아니라, 쓰기 데이터베이스와 물리적으로 분리되어 있는 구체화된 뷰에 대해 읽기를 실행할 수 있습니다. 따라서 읽기 및 쓰기 워크로드를 독립적으로 확장할 수 있고, 구체화된 뷰를 쿼리에 맞게 최적화할 수 있습니다.

CQRS는 대형 아키텍처의 하위 시스템에 적용하는 것이 좀 더 적합합니다. 일반적으로 전체 응용 프로그램에 이 아키텍처를 적용하면 불필요한 복잡성이 증가하므로 그렇게 하면 안 됩니다. 많은 사용자가 동일한 데이터에 액세스하는 공동 작업 도메인에는 이 아키텍처를 고려해 보세요.

### <a name="event-driven-architecture"></a>이벤트 기반 아키텍처 

<img src="./images/event-driven-sketch.svg" style="float:left; margin-top:6px;"/>

**[이벤트 기반 아키텍처](./event-driven.md)**는 생산자가 이벤트를 게시하고 소비자가 그 이벤트를 구독하는 게시-구독(pub-sub) 모델을 사용합니다. 생산자는 소비자와 독립적 관계이며, 소비자는 서로 독립적 관계입니다. 

IoT 솔루션처럼 대규모 데이터를 수집하여 처리하고 대기 시간이 매우 짧은 응용 프로그램에는 이벤트 기반 아키텍처를 고려해 보세요. 이 스타일은 여러 하위 시스템이 동일한 이벤트 데이터에서 다양한 종류의 처리 작업을 수행해야 하는 경우도 유용합니다.

<br />
### <a name="big-data-big-compute"></a>빅 데이터 및 큰 계산

**[빅 데이터](./big-data.md)** 및 **[큰 계산](./big-compute.md)**은 특정 프로필에 적합한 특수 아키텍처 스타일입니다. 빅 데이터는 매우 거대한 데이터 집합을 여러 청크로 분할한 후 전체 집합에 걸쳐 병렬 처리를 수행하여 데이터를 분석 및 보고합니다. HPC(고성능 컴퓨팅)라고도 하는 큰 계산은 수많은(수천 개) 코어에 걸쳐 병렬 계산을 만듭니다. 도메인에는 시뮬레이션, 모델링 및 3D 렌더링이 포함됩니다.

## <a name="architecture-styles-as-constraints"></a>아키텍처 스타일의 제약 조건

아키텍처 스타일은 표시할 수 있는 요소 집합 수 및 그러한 요소 사이에 허용되는 관계를 포함하여 디자인 제약 조건이 있습니다. 제약 조건은 선택 범위를 제한하여 아키텍처의 "모양"을 좌우합니다. 아키텍처가 특정 스타일의 제약 조건을 준수하면 바람직한 특정 속성이 드러납니다. 

예를 들어 마이크로 서비스의 제약 조건은 다음과 같습니다. 

- 서비스는 단일 책임을 나타냅니다. 
- 모든 서비스는 서로 독립적입니다. 
- 데이터는 해당 데이터를 소유하는 서비스 전용입니다. 서비스는 데이터를 공유하지 않습니다.

이러한 제약 조건을 준수하면 서비스를 독립적으로 배포할 수 있고, 오류가 격리되고, 업데이트를 자주 할 수 있고, 응용 프로그램에 새 기술을 쉽게 도입할 수 있는 시스템이 완성됩니다.

아키텍처 스타일을 선택하기 전에 해당 스타일의 기본 원칙 및 제약 조건을 이해해야 합니다. 그렇지 않으면 디자인이 표면적인 수준에서는 스타일을 준수하겠지만 해당 스타일의 잠재력을 모두 끌어내지는 못합니다. 실용성도 중요합니다. 아키텍처의 순수성을 고집하기 보다 제약 조건을 완화하는 것이 더 좋은 경우가 가끔 있습니다.


다음 표에는 각 스타일이 종속성을 관리하는 방법과 각 스타일에 가장 적합한 도메인 유형이 요약되어 있습니다.

| 아키텍처 스타일 |  종속성 관리 | 도메인 형식 |
|--------------------|------------------------|-------------|
| N 계층 | 서브넷으로 분할되는 가로 계층 | 전통적인 비즈니스 도메인. 업데이트 빈도가 낮습니다. |
| 웹-큐-작업자 | 비동기 메시지를 통해 분리되는 프런트 및 백 엔드 작업. | 일부 리소스 집약적인 작업이 있는 비교적 간단한 도메인. |
| 마이크로 서비스 | API를 통해 서로 호출하는 세로 방향으로(기능적으로) 분해되는 서비스. | 복잡한 도메인. 업데이트가 빈번합니다. |
| CQRS | 읽기/쓰기 분리. 스키마와 규모가 별도로 최적화됩니다. | 수많은 사용자가 동일한 데이터에 액세스하는 공동 작업 도메인. |
| 이벤트 기반 아키텍처. | 생산자/소비자. 하위 시스템마다 독립적 보기. | IoT 및 실시간 시스템 |
| 빅데이터 | 큰 데이터 집합을 작은 청크로 분할. 로컬 데이터 집합에서 병렬 처리. | 일괄 처리 및 실시간 데이터 분석. ML을 사용한 예측 분석. |
| 큰 계산| 수천 개의 코어에 데이터 할당. | 시뮬레이션 같은 계산 집약적 도메인. |


## <a name="consider-challenges-and-benefits"></a>과제 및 이점 고려

제약 조건은 그에 따른 과제가 있으므로 스타일을 채택할 때 반대 급부를 이해하는 것이 중요합니다. 아키텍처 스타일의 이점이 *이 하위 도메인 및 제한된 컨텍스트에 대한* 과제보다 큽니까? 

다음은 아키텍처 스타일을 선택할 때 고려해야 과제 중 일부입니다.

- **복잡성**. 아키텍처의 복잡성을 감수하고 도메인에 사용할 만한 가치가 있습니까? 정반대로, 도메인에 사용하기에 스타일이 너무 단순하지는 않습니까? 이 경우 아키텍처가 종속성을 깔끔하게 관리하는 데 도움이 되지 않기 때문에 결국에는 "[진흙공][ball-of-mud]"이 될 위험이 있습니다.

- **비동기 메시지 및 결과적 일관성**. 비동기 메시지를 사용하여 서비스를 분리하면 안정성(메시지를 검색할 수 있으므로) 및 확장성을 높일 수 있습니다. 그러나 이렇게 하면 항상 일회성 의미 체계 및 결과적 일관성 등의 과제가 발생합니다.

- **서비스 간 통신**. 응용 프로그램을 별도의 서비스로 분해하면 서비스 간 통신에서 허용할 수 없는 대기 시간이 발생하거나 네트워크 정체가 발생할(예를 들어 마이크로 서비스 아키텍처에서) 위험이 있습니다. 

- **관리 효율성**. 응용 프로그램을 관리, 모니터링, 배포, 업데이트하는 방법이 얼마나 어렵습니까?


[ball-of-mud]: https://en.wikipedia.org/wiki/Big_ball_of_mud
[microservices]: ./microservices.md
[n-tier]: ./n-tier.md