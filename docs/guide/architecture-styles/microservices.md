---
title: "마이크로 서비스 아키텍처 스타일"
description: "Azure에서 마이크로 서비스 아키텍처의 혜택, 과제 및 모범 사례를 설명합니다."
author: MikeWasson
ms.openlocfilehash: 08fd39b6cf0b3c88af654b27e21b2d7dd9fb19b1
ms.sourcegitcommit: 7764a804f000180c37a4f8dbab946b525f784f58
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/09/2018
---
# <a name="microservices-architecture-style"></a><span data-ttu-id="795f4-103">마이크로 서비스 아키텍처 스타일</span><span class="sxs-lookup"><span data-stu-id="795f4-103">Microservices architecture style</span></span>

<span data-ttu-id="795f4-104">마이크로 서비스 아키텍처는 작은 자율 서비스 컬렉션으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-104">A microservices architecture consists of a collection of small, autonomous services.</span></span> <span data-ttu-id="795f4-105">각 서비스는 자체 포함되며 단일 비즈니스 기능을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-105">Each service is self-contained and should implement a single business capability.</span></span> <span data-ttu-id="795f4-106">Azure에서 마이크로 서비스 아키텍처를 빌드하는 방법에 대한 자세한 지침은 [Azure에서 마이크로 서비스 설계, 구축 및 운영](../../microservices/index.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="795f4-106">For detailed guidance about building a microservices architecture on Azure, see [Designing, building, and operating microservices on Azure](../../microservices/index.md).</span></span>

![](./images/microservices-logical.svg)
 
<span data-ttu-id="795f4-107">일부 측면에서 마이크로 서비스는 SOA(서비스 지향 아키텍처)의 자연스러운 발전이지만 마이크로 서비스와 SOA 간에는 차이가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-107">In some ways, microservices are the natural evolution of service oriented architectures (SOA), but there are differences between microservices and SOA.</span></span> <span data-ttu-id="795f4-108">다음은 마이크로 서비스를 정의하는 몇 가지 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-108">Here are some defining characteristics of a microservice:</span></span>

- <span data-ttu-id="795f4-109">마이크로 서비스 아키텍처에서 서비스는 작고, 독립적이며, 느슨하게 결합되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-109">In a microservices architecture, services are small, independent, and loosely coupled.</span></span>

- <span data-ttu-id="795f4-110">각 서비스는 작은 개발 팀이 관리할 수 있는 개별 코드베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-110">Each service is a separate codebase, which can be managed by a small development team.</span></span>

- <span data-ttu-id="795f4-111">서비스를 독립적으로 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-111">Services can be deployed independently.</span></span> <span data-ttu-id="795f4-112">팀이 전체 응용 프로그램을 다시 빌드한 후 재배치하지 않고도 기존 서비스를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-112">A team can update an existing service without rebuilding and redeploying the entire application.</span></span>

- <span data-ttu-id="795f4-113">서비스가 해당 데이터 또는 외부 상태를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-113">Services are responsible for persisting their own data or external state.</span></span> <span data-ttu-id="795f4-114">이는 별도의 데이터 레이어가 데이터 지속성을 처리하는 기존 모델과의 차이점입니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-114">This differs from the traditional model, where a separate data layer handles data persistence.</span></span>

- <span data-ttu-id="795f4-115">서비스가 잘 정의된 API를 사용하여 서로 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-115">Services communicate with each other by using well-defined APIs.</span></span> <span data-ttu-id="795f4-116">각 서비스의 내부 구현 세부 정보는 다른 서비스에서 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-116">Internal implementation details of each service are hidden from other services.</span></span>

- <span data-ttu-id="795f4-117">서비스가 동일한 기술 스택, 라이브러리 또는 프레임워크를 공유할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-117">Services don't need to share the same technology stack, libraries, or frameworks.</span></span>

<span data-ttu-id="795f4-118">서비스 자체 외에도 다음과 같은 몇 가지 다른 구성 요소가 기존 마이크로 서비스 아키텍처에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-118">Besides for the services themselves, some other components appear in a typical microservices architecture:</span></span>

<span data-ttu-id="795f4-119">**관리**.</span><span class="sxs-lookup"><span data-stu-id="795f4-119">**Management**.</span></span> <span data-ttu-id="795f4-120">관리 구성 요소는 노드에 서비스 배치, 실패 식별, 노드 간에 서비스 부하 조정 등의 작업을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-120">The management component is responsible for placing services on nodes, identifying failures, rebalancing services across nodes, and so forth.</span></span>  

<span data-ttu-id="795f4-121">**서비스 검색**.</span><span class="sxs-lookup"><span data-stu-id="795f4-121">**Service Discovery**.</span></span>  <span data-ttu-id="795f4-122">서비스 목록과 서비스 목록이 배치되는 노드를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-122">Maintains a list of services and which nodes they are located on.</span></span> <span data-ttu-id="795f4-123">서비스 조회를 통해 서비스 끝점을 찾을 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-123">Enables service lookup to find the endpoint for a service.</span></span> 

<span data-ttu-id="795f4-124">**API 게이트웨이**.</span><span class="sxs-lookup"><span data-stu-id="795f4-124">**API Gateway**.</span></span> <span data-ttu-id="795f4-125">API 게이트웨이는 클라이언트의 진입점입니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-125">The API gateway is the entry point for clients.</span></span> <span data-ttu-id="795f4-126">클라이언트는 서비스를 직접 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-126">Clients don't call services directly.</span></span> <span data-ttu-id="795f4-127">대신, 호출을 백 엔드의 적절한 서비스에 전달하는 API 게이트웨이를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-127">Instead, they call the API gateway, which forwards the call to the appropriate services on the back end.</span></span> <span data-ttu-id="795f4-128">API 게이트웨이는 여러 서비스의 응답을 집계하고 집계된 응답을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-128">The API gateway might aggregate the responses from several services and return the aggregated response.</span></span> 

<span data-ttu-id="795f4-129">API 게이트웨이를 사용할 경우의 장점은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-129">The advantages of using an API gateway include:</span></span>

- <span data-ttu-id="795f4-130">클라이언트와 서비스가 분리됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-130">It decouples clients from services.</span></span> <span data-ttu-id="795f4-131">모든 클라이언트를 업데이트하지 않고도 서비스 버전을 관리하거나 서비스를 리팩터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-131">Services can be versioned or refactored without needing to update all of the clients.</span></span>

-  <span data-ttu-id="795f4-132">서비스가 웹 우호적이 아닌 AMQP 등의 메시징 프로토콜을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-132">Services can use messaging protocols that are not web friendly, such as AMQP.</span></span>

- <span data-ttu-id="795f4-133">API 게이트웨이는 인증, 로깅, SSL 종료, 부하 분산 등의 다른 교차 기능을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-133">The API Gateway can perform other cross-cutting functions such as authentication, logging, SSL termination, and load balancing.</span></span>

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="795f4-134">이 아키텍처를 사용하는 경우</span><span class="sxs-lookup"><span data-stu-id="795f4-134">When to use this architecture</span></span>

<span data-ttu-id="795f4-135">다음과 같은 경우 이 아키텍처 스타일을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-135">Consider this architecture style for:</span></span>

- <span data-ttu-id="795f4-136">높은 릴리스 개발속도가 필요한 대규모 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="795f4-136">Large applications that require a high release velocity.</span></span>

- <span data-ttu-id="795f4-137">고확장성이 필요한 복합 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="795f4-137">Complex applications that need to be highly scalable.</span></span>

- <span data-ttu-id="795f4-138">풍부한 도메인이나 많은 하위 도메인이 있는 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="795f4-138">Applications with rich domains or many subdomains.</span></span>

- <span data-ttu-id="795f4-139">소규모 개발 팀으로 구성된 조직.</span><span class="sxs-lookup"><span data-stu-id="795f4-139">An organization that consists of small development teams.</span></span>


## <a name="benefits"></a><span data-ttu-id="795f4-140">이점</span><span class="sxs-lookup"><span data-stu-id="795f4-140">Benefits</span></span> 

- <span data-ttu-id="795f4-141">**독립 배포**.</span><span class="sxs-lookup"><span data-stu-id="795f4-141">**Independent deployments**.</span></span> <span data-ttu-id="795f4-142">전체 응용 프로그램을 다시 배포하지 않고 서비스를 업데이트할 수 있고, 문제가 발생하면 업데이트를 롤백 또는 롤포워드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-142">You can update a service without redeploying the entire application, and roll back or roll forward an update if something goes wrong.</span></span> <span data-ttu-id="795f4-143">버그 수정 및 기능 릴리스 관리가 더 용이해지고 위험이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-143">Bug fixes and feature releases are more manageable and less risky.</span></span>

- <span data-ttu-id="795f4-144">**독립 개발**.</span><span class="sxs-lookup"><span data-stu-id="795f4-144">**Independent development**.</span></span> <span data-ttu-id="795f4-145">단일 개발 팀이 서비스를 빌드, 테스트 및 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-145">A single development team can build, test, and deploy a service.</span></span> <span data-ttu-id="795f4-146">그 결과, 연속적인 혁신과 더 빠른 릴리스 주기가 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-146">The result is continuous innovation and a faster release cadence.</span></span> 

- <span data-ttu-id="795f4-147">**집중화된 소규모 팀**.</span><span class="sxs-lookup"><span data-stu-id="795f4-147">**Small, focused teams**.</span></span> <span data-ttu-id="795f4-148">팀이 한 서비스에 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-148">Teams can focus on one service.</span></span> <span data-ttu-id="795f4-149">각 서비스의 범위가 작을수록 코드베이스 이해가 더 용이해지며 새로운 팀 구성원이 더 쉽게 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-149">The smaller scope of each service makes the code base easier to understand, and it's easier for new team members to ramp up.</span></span>

- <span data-ttu-id="795f4-150">**결함 격리**.</span><span class="sxs-lookup"><span data-stu-id="795f4-150">**Fault isolation**.</span></span> <span data-ttu-id="795f4-151">한 서비스가 다운되더라도 전체 응용 프로그램 작동은 중단되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-151">If a service goes down, it won't take out the entire application.</span></span> <span data-ttu-id="795f4-152">그러나 저절로 복원되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-152">However, that doesn't mean you get resiliency for free.</span></span> <span data-ttu-id="795f4-153">복원 모범 사례 및 디자인 패턴을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-153">You still need to follow resiliency best practices and design patterns.</span></span> <span data-ttu-id="795f4-154">[Azure용 복원 응용 프로그램 디자인][resiliency-overview]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="795f4-154">See [Designing resilient applications for Azure][resiliency-overview].</span></span>

- <span data-ttu-id="795f4-155">**혼합 기술 스택**.</span><span class="sxs-lookup"><span data-stu-id="795f4-155">**Mixed technology stacks**.</span></span> <span data-ttu-id="795f4-156">팀이 해당 서비스에 가장 적합한 기술을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-156">Teams can pick the technology that best fits their service.</span></span> 

- <span data-ttu-id="795f4-157">**세분화된 크기 조정**.</span><span class="sxs-lookup"><span data-stu-id="795f4-157">**Granular scaling**.</span></span> <span data-ttu-id="795f4-158">서비스를 독립적으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-158">Services can be scaled independently.</span></span> <span data-ttu-id="795f4-159">이와 동시에, VM당 서비스 수준이 높을수록 VM 리소스가 완전히 활용됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-159">At the same time, the higher density of services per VM means that VM resources are fully utilized.</span></span> <span data-ttu-id="795f4-160">배치 제약 조건을 사용하여 서비스를 VM 프로필(높은 CPU, 높은 메모리 등)에 맞출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-160">Using placement constraints, a services can be matched to a VM profile (high CPU, high memory, and so on).</span></span>

## <a name="challenges"></a><span data-ttu-id="795f4-161">과제</span><span class="sxs-lookup"><span data-stu-id="795f4-161">Challenges</span></span>

- <span data-ttu-id="795f4-162">**복잡성**.</span><span class="sxs-lookup"><span data-stu-id="795f4-162">**Complexity**.</span></span> <span data-ttu-id="795f4-163">마이크로 서비스 응용 프로그램에는 동등한 모놀리식 응용 프로그램보다 작동 부분이 더 많습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-163">A microservices application has more moving parts than the equivalent monolithic application.</span></span> <span data-ttu-id="795f4-164">각 서비스는 더 단순하지만 전체 시스템이 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-164">Each service is simpler, but the entire system as a whole is more complex.</span></span>

- <span data-ttu-id="795f4-165">**개발 및 테스트**.</span><span class="sxs-lookup"><span data-stu-id="795f4-165">**Development and test**.</span></span> <span data-ttu-id="795f4-166">서비스 종속성에 대한 개발 시 다른 접근 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-166">Developing against service dependencies requires a different approach.</span></span> <span data-ttu-id="795f4-167">기존 도구는 서비스 종속성 작업에 맞게 설계되지 않았을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-167">Existing tools are not necessarily designed to work with service dependencies.</span></span> <span data-ttu-id="795f4-168">서비스 경계를 벗어난 리팩터링은 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-168">Refactoring across service boundaries can be difficult.</span></span> <span data-ttu-id="795f4-169">특히 응용 프로그램이 빠르게 발전하는 경우 서비스 종속성을 테스트하기도 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-169">It is also challenging to test service dependencies, especially when the application is evolving quickly.</span></span>

- <span data-ttu-id="795f4-170">**통제 부족**.</span><span class="sxs-lookup"><span data-stu-id="795f4-170">**Lack of governance**.</span></span> <span data-ttu-id="795f4-171">마이크로 서비스 빌드에 대한 분산 접근 방법에는 장점이 있지만 문제가 발생할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-171">The decentralized approach to building microservices has advantages, but it can also lead to problems.</span></span> <span data-ttu-id="795f4-172">언어와 프레임워크가 너무 많아서 응용 프로그램 유지 관리가 어려워질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-172">You may end up with so many different languages and frameworks that the application becomes hard to maintain.</span></span> <span data-ttu-id="795f4-173">팀의 유연성을 지나치게 제한하지 않고 몇 가지 프로젝트 전체 표준을 적용하는 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-173">It may be useful to put some project-wide standards in place, without overly restricting teams' flexibility.</span></span> <span data-ttu-id="795f4-174">특히 로깅과 같은 교차 기능에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-174">This especially applies to cross-cutting functionality such as logging.</span></span>

- <span data-ttu-id="795f4-175">**네트워크 정체 및 대기 시간**.</span><span class="sxs-lookup"><span data-stu-id="795f4-175">**Network congestion and latency**.</span></span> <span data-ttu-id="795f4-176">다수의 작고 세분화된 서비스를 사용하면 서비스 간 통신이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-176">The use of many small, granular services can result in more interservice communication.</span></span> <span data-ttu-id="795f4-177">또한 서비스 종속성 체인이 너무 길어질 경우(서비스 A가 B를 호출하고, B가 C를 호출하고...) 추가 대기 시간이 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-177">Also, if the chain of service dependencies gets too long (service A calls B, which calls C...), the additional latency can become a problem.</span></span> <span data-ttu-id="795f4-178">API를 신중하게 디자인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-178">You will need to design APIs carefully.</span></span> <span data-ttu-id="795f4-179">통신량이 과도한 API를 피하고, 직렬화 형식을 고려하고, 비동기 통신 패턴을 사용할 영역을 찾아보세요.</span><span class="sxs-lookup"><span data-stu-id="795f4-179">Avoid overly chatty APIs, think about serialization formats, and look for places to use asynchronous communication patterns.</span></span>

- <span data-ttu-id="795f4-180">**데이터 무결성**.</span><span class="sxs-lookup"><span data-stu-id="795f4-180">**Data integrity**.</span></span> <span data-ttu-id="795f4-181">각 마이크로 서비스가 자체 데이터 지속성을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-181">With each microservice responsible for its own data persistence.</span></span> <span data-ttu-id="795f4-182">그 결과, 데이터 일관성이 과제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-182">As a result, data consistency can be a challenge.</span></span> <span data-ttu-id="795f4-183">가능한 경우 결과적 일관성을 수용합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-183">Embrace eventual consistency where possible.</span></span>

- <span data-ttu-id="795f4-184">**관리**.</span><span class="sxs-lookup"><span data-stu-id="795f4-184">**Management**.</span></span> <span data-ttu-id="795f4-185">마이크로 서비스에 성공하려면 성숙한 DevOps 문화가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-185">To be successful with microservices requires a mature DevOps culture.</span></span> <span data-ttu-id="795f4-186">전체 서비스의 상관관계 로깅이 까다로울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-186">Correlated logging across services can be challenging.</span></span> <span data-ttu-id="795f4-187">일반적으로 로깅은 단일 사용자 작업에 대한 여러 서비스 호출을 상호 연결해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-187">Typically, logging must correlate multiple service calls for a single user operation.</span></span>

- <span data-ttu-id="795f4-188">**버전 관리**.</span><span class="sxs-lookup"><span data-stu-id="795f4-188">**Versioning**.</span></span> <span data-ttu-id="795f4-189">서비스 업데이트로 인해 종속된 서비스가 손상되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-189">Updates to a service must not break services that depend on it.</span></span> <span data-ttu-id="795f4-190">언제든지 여러 서비스가 업데이트될 수 있으므로 신중하게 디자인하지 않으면 이전 버전 또는 이후 버전과의 호환성 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-190">Multiple services could be updated at any given time, so without careful design, you might have problems with backward or forward compatibility.</span></span>

- <span data-ttu-id="795f4-191">**기능**.</span><span class="sxs-lookup"><span data-stu-id="795f4-191">**Skillset**.</span></span> <span data-ttu-id="795f4-192">마이크로 서비스는 고도로 분산된 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-192">Microservices are highly distributed systems.</span></span> <span data-ttu-id="795f4-193">팀이 성공을 위한 기술과 경험을 가지고 있는지 신중하게 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-193">Carefully evaluate whether the team has the skills and experience to be successful.</span></span>

## <a name="best-practices"></a><span data-ttu-id="795f4-194">모범 사례</span><span class="sxs-lookup"><span data-stu-id="795f4-194">Best practices</span></span>

- <span data-ttu-id="795f4-195">비즈니스 도메인을 중심으로 서비스를 모델링합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-195">Model services around the business domain.</span></span> 

- <span data-ttu-id="795f4-196">모든 것을 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-196">Decentralize everything.</span></span> <span data-ttu-id="795f4-197">개별 팀이 서비스 디자인 및 빌드를 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-197">Individual teams are responsible for designing and building services.</span></span> <span data-ttu-id="795f4-198">코드 또는 데이터 스키마를 공유하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-198">Avoid sharing code or data schemas.</span></span> 

- <span data-ttu-id="795f4-199">데이터 저장소가 데이터를 소유하는 서비스의 개인용이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-199">Data storage should be private to the service that owns the data.</span></span> <span data-ttu-id="795f4-200">각 서비스 및 데이터 형식에 가장 적합한 저장소를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-200">Use the best storage for each service and data type.</span></span> 

- <span data-ttu-id="795f4-201">서비스가 잘 디자인된 API를 통해 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-201">Services communicate through well-designed APIs.</span></span> <span data-ttu-id="795f4-202">구현 세부 정보가 누출되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-202">Avoid leaking implementation details.</span></span> <span data-ttu-id="795f4-203">API는 서비스의 내부 구현이 아니라 도메인을 모델링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-203">APIs should model the domain, not the internal implementation of the service.</span></span>

- <span data-ttu-id="795f4-204">서비스 간의 결합을 피합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-204">Avoid coupling between services.</span></span> <span data-ttu-id="795f4-205">결합의 원인에는 공유 데이터베이스 스키마, 엄격한 통신 프로토콜 등이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-205">Causes of coupling include shared database schemas and rigid communication protocols.</span></span>

- <span data-ttu-id="795f4-206">인증, SSL 종료 등의 교차 문제를 게이트웨이에 오프로드합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-206">Offload cross-cutting concerns, such as authentication and SSL termination, to the gateway.</span></span>

- <span data-ttu-id="795f4-207">도메인 정보를 게이트웨이에서 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-207">Keep domain knowledge out of the gateway.</span></span> <span data-ttu-id="795f4-208">게이트웨이는 비즈니스 규칙 또는 도메인 논리를 몰라도 클라이언트 요청을 처리하고 라우트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-208">The gateway should handle and route client requests without any knowledge of the business rules or domain logic.</span></span> <span data-ttu-id="795f4-209">그러지 않으면 게이트웨이가 종속성이 되며 서비스 간에 결합이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-209">Otherwise, the gateway becomes a dependency and can cause coupling between services.</span></span>

- <span data-ttu-id="795f4-210">서비스에 느슨한 결합 및 높은 기능 응집력이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-210">Services should have loose coupling and high functional cohesion.</span></span> <span data-ttu-id="795f4-211">함께 변경될 가능성이 큰 기능은 함께 패키지하고 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-211">Functions that are likely to change together should be packaged and deployed together.</span></span> <span data-ttu-id="795f4-212">개별 서비스에 상주할 경우, 한 서비스가 변경되면 다른 서비스를 업데이트해야 하므로 해당 서비스가 긴밀하게 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-212">If they reside in separate services, those services end up being tightly coupled, because a change in one service will require updating the other service.</span></span> <span data-ttu-id="795f4-213">두 서비스 간의 과도한 통신량은 긴밀한 결합과 낮은 응집력의 증상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-213">Overly chatty communication between two services may be a symptom of tight coupling and low cohesion.</span></span> 

- <span data-ttu-id="795f4-214">실패를 격리합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-214">Isolate failures.</span></span> <span data-ttu-id="795f4-215">복원 전략을 사용하여 한 서비스 내의 실패가 계단식으로 연속되지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-215">Use resiliency strategies to prevent failures within a service from cascading.</span></span> <span data-ttu-id="795f4-216">[복원력 패턴][resiliency-patterns] 및 [복원력 있는 응용 프로그램 디자인][resiliency-overview]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="795f4-216">See [Resiliency patterns][resiliency-patterns] and [Designing resilient applications][resiliency-overview].</span></span>

## <a name="microservices-using-azure-container-service"></a><span data-ttu-id="795f4-217">Azure Container Service를 사용하는 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="795f4-217">Microservices using Azure Container Service</span></span> 

<span data-ttu-id="795f4-218">[Azure Container Service](/azure/container-service/)를 사용하여 Docker 클러스터를 구성 및 프로비전할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-218">You can use [Azure Container Service](/azure/container-service/) to configure and provision a Docker cluster.</span></span> <span data-ttu-id="795f4-219">Azure Container Service는 Kubernetes, DC/OS 및 Docker Swarm을 포함하여 여러 인기 컨테이너 오케스트레이터를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-219">Azure Container Services supports several popular container orchestrators, including Kubernetes, DC/OS, and Docker Swarm.</span></span>

![](./images/microservices-acs.png)
 
<span data-ttu-id="795f4-220">**공용 노드**.</span><span class="sxs-lookup"><span data-stu-id="795f4-220">**Public nodes**.</span></span> <span data-ttu-id="795f4-221">이 노드는 공용 부하 분산 장치를 통해 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-221">These nodes are reachable through a public-facing load balancer.</span></span> <span data-ttu-id="795f4-222">API 게이트웨이는 이 노드에 호스트됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-222">The API gateway is hosted on these nodes.</span></span>

<span data-ttu-id="795f4-223">**백 엔드 노드**.</span><span class="sxs-lookup"><span data-stu-id="795f4-223">**Backend nodes**.</span></span> <span data-ttu-id="795f4-224">이 노드는 클라이언트가 API 게이트웨이를 통해 연결하는 서비스를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-224">These nodes run services that clients reach via the API gateway.</span></span> <span data-ttu-id="795f4-225">이 노드는 인터넷 트래픽을 직접 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-225">These nodes don't receive Internet traffic directly.</span></span> <span data-ttu-id="795f4-226">백 엔드 노드에는 각각 다른 하드웨어 프로필을 사용하는 두 개 이상의 VM 풀이 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-226">The backend nodes might include more than one pool of VMs, each with a different hardware profile.</span></span> <span data-ttu-id="795f4-227">예를 들어 일반 계산 워크로드, 높은 CPU 워크로드 및 높은 메모리 워크로드를 위해 개별 풀을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-227">For example, you could create separate pools for general compute workloads, high CPU workloads, and high memory workloads.</span></span> 

<span data-ttu-id="795f4-228">**관리 VM**.</span><span class="sxs-lookup"><span data-stu-id="795f4-228">**Management VMs**.</span></span> <span data-ttu-id="795f4-229">이 VM은 컨테이너 오케스트레이터의 마스터 노드를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-229">These VMs run the master nodes for the container orchestrator.</span></span> 

<span data-ttu-id="795f4-230">**네트워킹**.</span><span class="sxs-lookup"><span data-stu-id="795f4-230">**Networking**.</span></span> <span data-ttu-id="795f4-231">공용 노드, 백 엔드 노드 및 관리 VM은 동일한 VNet(가상 네트워크) 내의 개별 서브넷에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-231">The public nodes, backend nodes, and management VMs are placed in separate subnets within the same virtual network (VNet).</span></span> 

<span data-ttu-id="795f4-232">**부하 분산 장치**.</span><span class="sxs-lookup"><span data-stu-id="795f4-232">**Load balancers**.</span></span>  <span data-ttu-id="795f4-233">외부 연결 부하 분산 장치는 공용 노드 앞에 배치되고,</span><span class="sxs-lookup"><span data-stu-id="795f4-233">An externally facing load balancer sits in front of the public nodes.</span></span> <span data-ttu-id="795f4-234">공용 노드에 인터넷 요청을 분배합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-234">It distributes internet requests to the public nodes.</span></span> <span data-ttu-id="795f4-235">다른 부하 분산 장치는 관리 VM 앞에 배치되어 NAT 규칙을 사용하여 관리 VM에 대한 ssh(보안 셸) 트래픽을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-235">Another load balancer is placed in front of the management VMs, to allow secure shell (ssh) traffic to the management VMs, using NAT rules.</span></span>

<span data-ttu-id="795f4-236">안정성과 확장성을 위해 각 서비스가 여러 VM에 복제됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-236">For reliability and scalability, each service is replicated across multiple VMs.</span></span> <span data-ttu-id="795f4-237">그러나 서비스는 모놀리식 응용 프로그램에 비해 상대적으로 경량이므로 일반적으로 여러 서비스가 단일 VM에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-237">However, because services are also relatively lightweight (compared with a monolithic application), multiple services are usually packed into a single VM.</span></span> <span data-ttu-id="795f4-238">밀도가 높을수록 리소스 사용률이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-238">Higher density allows better resource utilization.</span></span> <span data-ttu-id="795f4-239">특정 서비스가 많은 리소스를 사용하지 않는 경우 해당 서비스를 실행하기 위해 전체 VM을 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-239">If a particular service doesn't use a lot of resources, you don't need to dedicate an entire VM to running that service.</span></span>

<span data-ttu-id="795f4-240">다음 다이어그램은 네 가지 서비스(각기 다른 도형으로 표시됨)를 실행하는 세 개의 노드를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-240">The following diagram shows three nodes running four different services (indicated by different shapes).</span></span> <span data-ttu-id="795f4-241">각 서비스에 두 개 이상의 인스턴스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-241">Notice that each service has at least two instances.</span></span> 
 
![](./images/microservices-node-density.png)

## <a name="microservices-using-azure-service-fabric"></a><span data-ttu-id="795f4-242">Azure Service Fabric을 사용하는 마이크로 서비스</span><span class="sxs-lookup"><span data-stu-id="795f4-242">Microservices using Azure Service Fabric</span></span>

<span data-ttu-id="795f4-243">다음 다이어그램은 [Azure Service Fabric](/azure/service-fabric/)을 사용하는 마이크로 서비스 아키텍처를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-243">The following diagram shows a microservices architecture using [Azure Service Fabric](/azure/service-fabric/).</span></span>

![](./images/service-fabric.png)

<span data-ttu-id="795f4-244">Service Fabric 클러스터는 하나 이상의 VM 확장 집합에 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-244">The Service Fabric cluster is deployed to one or more VM scale sets.</span></span> <span data-ttu-id="795f4-245">VM 유형을 섞어서 사용하기 위해 클러스터에 두 개 이상의 VM 확장 집합을 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-245">You might have more than one VM scale set in the cluster, in order to have a mix of VM types.</span></span> <span data-ttu-id="795f4-246">API 게이트웨이는 Service Fabric 클러스터의 앞에 배치되고 외부 부하 분산 장치가 클라이언트 요청을 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-246">An API Gateway is placed in front of the Service Fabric cluster, with an external load balancer to receive client requests.</span></span>

<span data-ttu-id="795f4-247">Service Fabric 런타임은 서비스 배치, 노드 장애 조치(failover) 및 상태 모니터링을 비롯한 클러스터 관리를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-247">The Service Fabric runtime performs cluster management, including service placement, node failover, and health monitoring.</span></span> <span data-ttu-id="795f4-248">런타임은 클러스터 노드 자체에 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-248">The runtime is deployed on the cluster nodes themselves.</span></span> <span data-ttu-id="795f4-249">별도의 클러스터 관리 VM 집합이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-249">There isn't a separate set of cluster management VMs.</span></span>

<span data-ttu-id="795f4-250">서비스는 Service Fabric에 빌드된 역방향 프록시를 사용하여 서로 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-250">Services communicate with each other using the reverse proxy that is built into Service Fabric.</span></span> <span data-ttu-id="795f4-251">Service Fabric은 명명된 서비스의 끝점을 확인할 수 있는 검색 서비스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="795f4-251">Service Fabric provides a discovery service that can resolve the endpoint for a named service.</span></span>


<!-- links -->

[resiliency-overview]: ../../resiliency/index.md
[resiliency-patterns]: ../../patterns/category/resiliency.md



