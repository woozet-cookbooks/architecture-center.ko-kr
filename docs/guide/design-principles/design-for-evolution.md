---
title: 변화를 위한 디자인
description: 혁신적인 디자인은 지속적인 혁신의 핵심입니다.
author: MikeWasson
ms.openlocfilehash: 9873d5c4e19d738a77a222e1f9a878ac5f5d125f
ms.sourcegitcommit: 26b04f138a860979aea5d253ba7fecffc654841e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/19/2018
ms.locfileid: "36206629"
---
# <a name="design-for-evolution"></a><span data-ttu-id="0e5a8-103">진화를 위한 디자인</span><span class="sxs-lookup"><span data-stu-id="0e5a8-103">Design for evolution</span></span>

## <a name="an-evolutionary-design-is-key-for-continuous-innovation"></a><span data-ttu-id="0e5a8-104">혁신적인 디자인은 지속적인 혁신의 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-104">An evolutionary design is key for continuous innovation</span></span>

<span data-ttu-id="0e5a8-105">성공적인 모든 응용 프로그램은 시간에 따라 버그를 수정하거나, 새 기능을 추가하거나, 새 기술을 가져오거나, 기존 시스템의 확장성과 복원력을 개선하는 등, 지속적으로 발전합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-105">All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient.</span></span> <span data-ttu-id="0e5a8-106">응용 프로그램의 모든 부분이 밀접하게 연결되어 있으면 시스템을 변경하는 것이 매우 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-106">If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system.</span></span> <span data-ttu-id="0e5a8-107">응용 프로그램의 한 부분이 달라지면 다른 부분이 중단되거나, 이러한 변경이 전체 코드 베이스에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-107">A change in one part of the application may break another part, or cause changes to ripple through the entire codebase.</span></span>

<span data-ttu-id="0e5a8-108">이 문제는 모놀리식 응용 프로그램으로만 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-108">This problem is not limited to monolithic applications.</span></span> <span data-ttu-id="0e5a8-109">응용 프로그램은 서비스로 분해될 수 있지만, 여전히 견고한 결합을 통해 시스템을 융통성 없는 불안정한 상태로 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-109">An application can be decomposed into services, but still exhibit the sort of tight coupling that leaves the system rigid and brittle.</span></span> <span data-ttu-id="0e5a8-110">하지만 개선될 수 있게 서비스를 디자인하면 팀은 혁신을 통해 새 기능을 계속 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-110">But when services are designed to evolve, teams can innovate and continuously deliver new features.</span></span> 

<span data-ttu-id="0e5a8-111">마이크로 서비스는 여기에 나열된 많은 고려 사항을 해결해주므로 혁신적 디자인을 달성하는 유용한 방법이 되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-111">Microservices are becoming a popular way to achieve an evolutonary design, because they address many of the considerations listed here.</span></span>

## <a name="recommendations"></a><span data-ttu-id="0e5a8-112">권장 사항</span><span class="sxs-lookup"><span data-stu-id="0e5a8-112">Recommendations</span></span>

<span data-ttu-id="0e5a8-113">**높은 응집력 및 느슨한 결합 적용**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-113">**Enforce high cohesion and loose coupling**.</span></span> <span data-ttu-id="0e5a8-114">서비스는 논리적으로 함께 속하는 기능을 제공할 경우 *응집력*을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-114">A service is *cohesive* if it provides functionality that logically belongs together.</span></span> <span data-ttu-id="0e5a8-115">다른 서비스를 변경하지 않으면서 서비스를 변경할 수 있는 경우 서비스가 *느슨하게 결합된* 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-115">Services are *loosely coupled* if you can change one service without changing the other.</span></span> <span data-ttu-id="0e5a8-116">높은 응집력은 일반적으로 한 기능을 변경할 때 관련된 다른 기능도 변경해야 하는 경우를 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-116">High cohesion generally means that changes in one function will require changes in other related functions.</span></span> <span data-ttu-id="0e5a8-117">@@한 서비스를 업데이트하기 위해 다른 서비스도 통합해서 업데이트해야 할 경우 서비스가 응집력을 갖는다는 것을 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-117">If you find that updating a service requires coordinated updates to other services, it may be a sign that your services are not cohesive.</span></span> <span data-ttu-id="0e5a8-118">DDD(도메인 기반 디자인)의 목표 중 하나는 경계를 구분하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-118">One of the goals of domain-driven design (DDD) is to identify those boundaries.</span></span>

<span data-ttu-id="0e5a8-119">**도메인 지식 캡슐화**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-119">**Encapsulate domain knowledge**.</span></span> <span data-ttu-id="0e5a8-120">클라이언트가 서비스를 사용하는 경우 도메인의 비즈니스 규칙 적용에 대한 책임은 클라이언트에 있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-120">When a client consumes a service, the responsibility for enforcing the business rules of the domain should not fall on the client.</span></span> <span data-ttu-id="0e5a8-121">대신, 서비스가 책임이 있는 모든 도메인 지식을 캡슐화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-121">Instead, the service should encapsulate all of the domain knowledge that falls under its responsibility.</span></span> <span data-ttu-id="0e5a8-122">그렇지 않으면, 모든 클라이언트가 비즈니스 규칙을 적용해야 ㅏ며, 결과적으로 응용 프로그램의 다른 부분으로 도메인 지식이 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-122">Otherwise, every client has to enforce the business rules, and you end up with domain knowledge spread across different parts of the application.</span></span> 

<span data-ttu-id="0e5a8-123">**비동기 메시징 사용**</span><span class="sxs-lookup"><span data-stu-id="0e5a8-123">**Use asynchronous messaging**.</span></span> <span data-ttu-id="0e5a8-124">비동기 메시징은 소비자로부터 메시지 생산자를 분리하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-124">Asynchronous messaging is a way to decouple the message producer from the consumer.</span></span> <span data-ttu-id="0e5a8-125">생산자는 메시지에 응답하거나 특정 작업을 수행하는 소비자에 종속되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-125">The producer does not depend on the consumer responding to the message or taking any particular action.</span></span> <span data-ttu-id="0e5a8-126">pub/sub 아키텍처를 사용하면 생산자가 메시지를 사용하는 대상을 모를 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-126">With a pub/sub architecture, the producer may not even know who is consuming the message.</span></span> <span data-ttu-id="0e5a8-127">새 서비스는 생산자를 수정하지 않고 메시지를 쉽게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-127">New services can easily consume the messages without any modifications to the producer.</span></span>

<span data-ttu-id="0e5a8-128">**도메인 지식을 게이트웨이에 구축하지 않음**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-128">**Don't build domain knowledge into a gateway**.</span></span> <span data-ttu-id="0e5a8-129">요청 라우팅, 프로토콜 변환, 부하 분산, 인증 등의 경우 마이크로 서비스 아키텍처에서 게이트웨이가 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-129">Gateways can be useful in a microservices architecture, for things like request routing, protocol translation, load balancing, or authentication.</span></span> <span data-ttu-id="0e5a8-130">그러나 게이트웨이는 이러한 종류의 인프라 기능으로 제한해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-130">However, the gateway should be restricted to this sort of infrastructure functionality.</span></span> <span data-ttu-id="0e5a8-131">과도하게 종속되는 것을 방지하려면 도메인 지식은 구현하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-131">It should not implement any domain knowledge, to avoid becoming a heavy dependency.</span></span>

<span data-ttu-id="0e5a8-132">**개방형 인터페이스 노출**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-132">**Expose open interfaces**.</span></span> <span data-ttu-id="0e5a8-133">서비스 사이에 사용자 지정 변환 레이어를 만들지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-133">Avoid creating custom translation layers that sit between services.</span></span> <span data-ttu-id="0e5a8-134">대신, 서비스는 잘 정의된 API 계약이 있는 API를 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-134">Instead, a service should expose an API with a well-defined API contract.</span></span> <span data-ttu-id="0e5a8-135">이전 버전과의 호환성을 유지하면서 API를 확장할 수 있도록 API 버전을 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-135">The API should be versioned, so that you can evolve the API while maintaining backward compatibility.</span></span> <span data-ttu-id="0e5a8-136">이런 방식으로 의존하는 모든 업스트림 서비스에 대한 업데이트를 통합하지 않고도 서비스를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-136">That way, you can update a service without coordinating updates to all of the upstream services that depend on it.</span></span> <span data-ttu-id="0e5a8-137">공용 서비스는 HTTP를 통해 RESTful API를 노출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-137">Public facing services should expose a RESTful API over HTTP.</span></span> <span data-ttu-id="0e5a8-138">백 엔드 서비스는 성능상의 이유로 RPC 스타일 메시징 프로토콜을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-138">Backend services might use an RPC-style messaging protocol for performance reasons.</span></span> 

<span data-ttu-id="0e5a8-139">**서비스 계약을 고려한 디자인 및 테스트**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-139">**Design and test against service contracts**.</span></span> <span data-ttu-id="0e5a8-140">서비스가 잘 정의된 API를 노출하는 경우 이러한 API를 고려해서 개발을 수행하고 테스트를 진행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-140">When services expose well-defined APIs, you can develop and test against those APIs.</span></span> <span data-ttu-id="0e5a8-141">이러한 방식으로, 해당하는 모든 종속 서비스를 포함하지 않고도 개별 서비스를 개발하고 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-141">That way, you can develop and test an individual service without spinning up all of its dependent services.</span></span> <span data-ttu-id="0e5a8-142">(물론 여전히 실제 서비스를 고려해서 통합 및 부하 테스트를 수행할 수 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="0e5a8-142">(Of course, you would still perform integration and load testing against the real services.)</span></span>

<span data-ttu-id="0e5a8-143">**추상 인프라를 도메인 논리와 분리**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-143">**Abstract infrastructure away from domain logic**.</span></span> <span data-ttu-id="0e5a8-144">도메인 논리를 메시징 또는 지속성 같은 인프라 관련 기능과 혼합하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-144">Don't let domain logic get mixed up with infrastructure-related functionality, such as messaging or persistence.</span></span> <span data-ttu-id="0e5a8-145">이러한 기능이 혼합되면 도메인 논리를 변경하려는 경우 인프라 계층을 업데이트해야 하고, 그 반대의 경우도 마찬가지가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-145">Otherwise, changes in the domain logic will require updates to the infrastructure layers and vice versa.</span></span> 

<span data-ttu-id="0e5a8-146">**교차 적용되는 문제를 별도 서비스에 오프로드**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-146">**Offload cross-cutting concerns to a separate service**.</span></span> <span data-ttu-id="0e5a8-147">예를 들어, 몇 가지 서비스가 요청을 인증해야 할 경우, 이 기능을 자체 서비스로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-147">For example, if several services need to authenticate requests, you could move this functionality into its own service.</span></span> <span data-ttu-id="0e5a8-148">그런 후 인증 서비스를 사용하는 다른 서비스를 건드리지 않으면서 해당 인증 서비스를 개선할 수 있습니다(예: 새 인증 흐름 추가).</span><span class="sxs-lookup"><span data-stu-id="0e5a8-148">Then you could evolve the authentication service &mdash; for example, by adding a new authentication flow &mdash; without touching any of the services that use it.</span></span>

<span data-ttu-id="0e5a8-149">**서비스를 독립적으로 배포**.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-149">**Deploy services independently**.</span></span> <span data-ttu-id="0e5a8-150">DevOps 팀이 응용 프로그램의 다른 서비스와는 별개로 단일 서비스를 배포할 수 있는 경우 업데이트가 더 빠르고 안전하게 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-150">When the DevOps team can deploy a single service independently of other services in the application, updates can happen more quickly and safely.</span></span> <span data-ttu-id="0e5a8-151">버그 픽스와 새로운 기능은 좀 더 규칙적으로 롤아웃될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-151">Bug fixes and new features can be rolled out at a more regular cadence.</span></span> <span data-ttu-id="0e5a8-152">독립적인 업데이트를 지원하도록 응용 프로그램과 릴리스 프로세스를 디자인하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0e5a8-152">Design both the application and the release process to support independent updates.</span></span>